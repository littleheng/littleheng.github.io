<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zahra</title>
  
  <subtitle>种一棵树最好的时间是十年前，其次是现在。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://littleheng.gitee.io/"/>
  <updated>2019-06-20T04:17:19.528Z</updated>
  <id>https://littleheng.gitee.io/</id>
  
  <author>
    <name>zahra</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS随记</title>
    <link href="https://littleheng.gitee.io/2019/06/20/CSS%E9%9A%8F%E8%AE%B0/"/>
    <id>https://littleheng.gitee.io/2019/06/20/CSS随记/</id>
    <published>2019-06-20T02:50:11.000Z</published>
    <updated>2019-06-20T04:17:19.528Z</updated>
    
    <content type="html"><![CDATA[<!-- # css小记 --><!-- [toc] --><p> 最近在公司做前端方面的工作，涉及到页面的编写。特此将刚刚知道的知识和碰过的坑整理一下，想到哪便写到哪。方便查阅。</p><p> 写页面时注意兼容性，需要hack写法的就要多查阅不同浏览器版本的语法。也可以尝试新的技术。比如less、sass、stylus等。</p><hr><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul><li>编写页面之前，记得初始化背景画布，因为浏览器先是加载DOM树，然后再将元素的默认属性画上去。有一些元素的默认属性会影响页面布局和定位。例如ul有默认的换行（外边距）和左内边距。</li></ul><ul><li><p>页面初始化需要的三种样式：</p><ul><li>重置样式(reset)：html的许多标签是有默认样式的。需要将它们初始化。</li><li>公共样式(common)：公用的，可重复使用的样式。</li><li>独立样式：相对于某个页面单独使用的样式。</li></ul></li></ul><pre><code>* {     margin: 0;    padding: 0px;  &lt;!-- 值为1个时对应所有；值为2个时对应上下、左右；值为3个时对应上、左右、下；值为4个时分别对应上、右、下、左。  --&gt;    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;      -ms-box-sizing: border-box;      -o-box-sizing: border-box;      box-sizing: border-box;  }body {    background-color: #f8f8fd;      font-size: 0.875rem;      /*  max-width: 10rem;  */  }</code></pre><p> 可以设置默认的<strong>body背景色</strong>，元素之间切割有距离时露出背景色挺方便。</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p><br> 使用<strong>rem</strong>做移动端网页，font-size应初始化在html根元素上，一般浏览器默认值为<strong>16px = 1rem</strong>。如果根元素为16px，那么每增加2px会增加0.125rem。每增加10px会增加0.625rem。(google浏览器默认中文最小字体为12px。&lt;12一律显示为12px大小。但允许设置为0。最小字体限制数可以在浏览器的设置中更改)</p><h4 id="max-width、min-width"><a href="#max-width、min-width" class="headerlink" title="max-width、min-width"></a>max-width、min-width</h4><p><br> 使用<strong>max-width</strong>属性时，要小心，它可以让浏览器更好的处理小窗口的情况。这点在移动设备上尤为重要。我记得我使用了两次，第一次很成功，第二次页面就缩小了一半、、、暂时不知道为啥。使用min-width时，如果最小宽度大于可视宽度，会出现滚动条；当可视宽度变化为小于或等于最小宽度时，页面内容不会随宽度的缩小而缩小。可能部分内容需要移动滚动条才可查看。</p><h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><p><br> 在我的印象中，一个简单的应用是块级元素（display: block）可以使用此属性轻松居中。简单又很酷。</p><pre><code>div {    display: block;    margin: 0 auto;    max-width: 600px;    /*    当div的宽度大于可视区的宽度时，浏览器会显示一个水平滚动条来容纳页面。用这个属性可以避免这种情况。更酷。    */  }</code></pre><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><pre><code>box-sizing: border-box  (内边距、边框宽度在设置的元素尺寸之内。盒子尺寸=设置的元素尺寸);   box-sizing: content-box  (内边距、边框宽度、外边距在设置的元素尺寸的外围。盒子实际尺寸&gt;=设置的元素尺寸);</code></pre><blockquote><p>注：为了向前兼容老版本的浏览器，某些属性会加前缀<br>  <strong>-webkit-</strong>：google,safari私有属性;<br>  <strong>-moz-</strong>：firefox私有属性;<br>  <strong>-ms-</strong>：internet explorer私有属性;<br>  <strong>-o-</strong>：opera私有属性;</p></blockquote><pre><code>-webkit-box-sizing: border-box;-moz-box-sizing: border-box;-ms-box-sizing: border-box;-o-box-sizing: border-box;box-sizing: border-box;</code></pre><hr><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p><br></p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p> <br> 弹性布局/伸缩盒子。设为flex布局后，子元素的float、clear、vertical-align属性将失效。</p><pre><code>.flex {    display: -webkit-flex;    display: flex;  }  /*  webkit内核的浏览器，必须加上-webkit-前缀  */  .div1 {    -moz-box-flex: 1.0;      -webkit-box-flex: 1.0;    box-flex: 1.0;  }.div2 {    -moz-box-flex: 2.0;    -webkit-box-flex: 2.0;    box-flex: 2.0;  }</code></pre><p><br>      </p><h4 id="box"><a href="#box" class="headerlink" title="box"></a>box</h4><p> <br> box-flex主要让子容器针对父容器的宽度按一定规则进行划分</p><h5 id="box属性"><a href="#box属性" class="headerlink" title="box属性"></a>box属性</h5><pre><code>box-orient | box-direction | box-align | box-pack | box-lines</code></pre><ul><li>box-orient<br>用来确定父容器里子容器的排列方式，是水平还是垂直。</li></ul><pre><code>horizontal | vertical | inline-axis | block-axis | inherit</code></pre><p> 给box设置horizontal或inline-axis属性其效果似乎表现一致，都可将子容器水平排列</p><p> 如果父容器选择horizontal或inline-axis属性对子容器进行水平排列，其是对父容器的宽度进行分配划分。此时如果父容器定义了高度值，其子容器的高度值设置则无效状态，所有子容器的高度等于父容器的高度值；如果父容器不设置高度值，其子容器的高度值才有效并且取最大高度值的子容器的高度。</p><p> 给box设置vertical或block-axis属性(此属性是默认值)其效果似乎表现一致，都可将子容器垂直排列</p><p> 如果父容器选择vertical或block-axis属性对子容器进行垂直排列，其是对父容器的高度进行分配划分。此时如果父容器<br>定义了宽度值，其子容器的宽度值设置则无效状态；如果父容器不设置宽度值，其子容器的宽度值才有效并且取最大宽度值的子容器的宽度。</p><p> inherit属性则是让子容器继承父容器的相关属性</p><ul><li>box-direction<br>用来确定父容器里的子容器排列顺序</li></ul><pre><code>normal | reverse | inherit&lt;!-- normal是默认值，按照HTML文档里结构的先后顺序依次展示 --&gt;&lt;!-- reverse表示反转 --&gt;</code></pre><ul><li>box-align<br>表示父容器里面子容器的垂直对齐方式</li></ul><pre><code>start | end | center | baseline | stretch&lt;!-- start：在box-align表示居顶对齐 --&gt;&lt;!-- end：在box-align表示居底对齐 --&gt;&lt;!-- center：在box-align表示居中对齐 --&gt;&lt;!-- stretch：在box-align表示拉伸，拉伸到与父容器等高 --&gt;</code></pre><ul><li>box-pack<br>表示父容器里面子容器的水平对齐方式</li></ul><pre><code>start | end | center | justify&lt;!-- start：在box-pack表示水平居左对齐 --&gt;&lt;!-- end：在box-pack表示水平居右对齐 --&gt;&lt;!-- center：在box-pack表示水平居中对齐 --&gt;&lt;!-- justify:在box-pack表示水平等分父容器宽度 --&gt;</code></pre><p><a href="https://www.cnblogs.com/leejersey/p/3795885.html" target="_blank" rel="noopener">移动web开发实践-css3（1）盒模型display:-webkit-box;的使用</a></p><p><br></p><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p><br> 定位和z-index配合使用时，可以将元素分为不同的层级。</p><ul><li>常用的属性值 <ul><li>relative：相对定位</li><li>absolute：绝对定位</li><li>fixed：固定定位</li></ul></li></ul><h5 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h5><p><br> 默认使用相对定位时，元素是相对于原有位置进行移动。移动完成后，它依然存在于原来的文档流中，所以在原有位置会有一段空白，如果不注意的话，就无法得到自己想要的效果。这时可以试试将元素的外边距设为负数看能不能达到相同的效果。</p><pre><code>&lt;!-- 使用相对定位移动元素 --&gt;.cover {    position: relative;    top: -10px; &lt;!-- 会在原有位置留有空白 --&gt;}&lt;!-- 使用margin实现同样的效果 --&gt;.cover {    margin-top: -10px;    &lt;!-- 不会留有空白 --&gt;}</code></pre><h5 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h5><p><br> 使用绝对定位时，场景比较多的是先将父元素进行相对定位（relative），再将子元素设置为绝对定位（absolute），再根据实际情况上下左右调整距离。absolute定位的元素会脱离文档流，如果父元素里面没有其他在文档流中的元素时，父元素会塌陷。</p><pre><code>.father {    postion: relative}.son {    postion: absolute;    top: 0;    bottom: 0;    left: 0;    right: 0;    &lt;!-- son元素位置无变化，在父元素的左上角 --&gt;}</code></pre><h5 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h5><p><br> 固定定位可以将元素固定在某一个位置，不随滚动条的滚动而滚动，可以简单视为相对于可视区去定位。</p><pre><code>&lt;!-- 实现移动端页面底部菜单浮动 --&gt;.footer-menu {    width: 100%;    position: fixed;    bottom: 0;  }</code></pre><p><a href="http://ife.baidu.com/note/detail/id/662" target="_blank" rel="noopener">理解绝对定位</a></p><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p><br> 这是一个神奇的属性，有非常多的属性值。对布局很有用。不过我只掌握了常用的几种。（inline，inline-block，block）</p><ul><li><p><strong>inline</strong><br>显示为内联元素，不可设置元素宽高、垂直居中，内边距只对左、右、下起作用，外边距只对左、右起作用。可设置文本对齐。<br>不过使用绝对定位/浮动后，inline元素变为inline-block元素。以上的效果都有效。</p></li><li><p><strong>inline-block</strong><br>这是我使用的比较多的一个值，也是我认为比较酷的一个选项。我经常使用它来将多个li元素排列为一行。它同时具备内联元素、块级元素的特点。（内联块状元素）它有如下特点：<br>a. 和其他元素都在一行上<br>b. 元素的宽、高、行高以及顶和底边距都可以设置<br>c. vertical-align属性会影响到inline-block元素    ，你可能会把它的值设置为top<br>d. 你需要设置每一列的宽度<br>e. 如果HTML源代码中元素之间有空格，那么列与列    之间会产生空隙</p></li></ul><ul><li><strong>block</strong><br>块级元素，可设置宽、高、内外边距、行高、、、独占一行。</li></ul><h4 id="百分比宽度"><a href="#百分比宽度" class="headerlink" title="百分比宽度"></a>百分比宽度</h4><p><br> 百分比是一种相对于包含块的计量单位。这个简直不要太爽。我经常利用它加inline-block实现li元素多行多列的布局。</p><pre><code>父元素  div {    width: 100%;    background-color: #fff;  }  li {    /*    宽度随需求而定，24%相当于一行显示4列    */    width: 24%;    display: inline-block;  /*这个是关键  */    text-align: center;    /*可以让li内的元素居中 */    padding: 0.3125rem 03125rem;    /*可以使布局更美观 */    position: relative;    /*与子元素的绝对定位使用，你让它向东绝不会向西。 */  }或者li {    width: 25%;      float: left;}</code></pre><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p><br> 经常出现一个情况，子元素全部浮动起来了，然后父元素没有被撑起来。曾经让我很抠脑壳。后来终于发现了两种方法解决这个顽疾。  </p><ul><li><p>在父元素中再添加一个子元素，设置子元素不透明度为0（opacity: 0）。然后子元素再clear:    both。完美结局。  </p></li><li><p>但是我更喜欢第二种，不用添加元素。使用伪类实现。  </p></li></ul><pre><code>img(浮动的元素或父元素):after,img:before {      content: &apos;&apos;,      clear: both;}</code></pre><p>经常使用的清除浮动的类：</p><pre><code>.clearfix:before,.clearfix:after {    content: &apos;&apos;;    display: table;}.clearfix:after {   &lt;!-- 伪类与前面的冒号不能有空格，有空格会失效 --&gt;    clear: both;}</code></pre><p><a href="http://zh.learnlayout.com/toc.html" title="点击吧，超实用" target="_blank" rel="noopener">这里</a>有网页布局的许多知识。曾经帮助我实现css布局入门。</p><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><br></p><h4 id="一行文本省略"><a href="#一行文本省略" class="headerlink" title="一行文本省略"></a>一行文本省略</h4><pre><code>overflow: hidden;text-overflow: ellipsis;    //  ...white-space: nowrap;    </code></pre><p>多行可以加上line-height和display配合使用。(貌似还有height)</p><h4 id="img和span行内对齐"><a href="#img和span行内对齐" class="headerlink" title="img和span行内对齐"></a>img和span行内对齐</h4><p><br> 只能说我太笨了，某天遇到这个坑时，纠结了半天，左调调右调调，就是对不齐，抠脑壳。最后发现是如此的简单。  </p><pre><code>img {      width: 1.25rem;      height: 1.25rem;      vertical-align: middle;  }  span {      display: inline-block;      vertical-align: middle;  }  </code></pre><p>  <em>注意：两个元素必须都是inline-block元素，并且img一定要设置宽、高。 </em><br><br>  </p><h4 id="media-css3"><a href="#media-css3" class="headerlink" title="@media(css3)"></a>@media(css3)</h4><p><br><br> 1、 语法</p><pre><code>@media mediaType and|not|only (media feature) {      /*CSS-Code;*/  }</code></pre><p> 媒体类型（mediaType ）：常用</p><pre><code>all    用于所有设备print    用于打印机和打印预览screen    用于电脑屏幕，平板电脑，智能手机等。speech    应用于屏幕阅读器等发声设备</code></pre><p>媒体功能（media feature）：常用</p><pre><code>max-width    定义输出设备中的页面最大可见区域宽度min-width    定义输出设备中的页面最小可见区域宽度</code></pre><p> 2、 准备工作  </p><ul><li>设置Meta标签</li></ul><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;</code></pre><p>width = device-width：宽度等于当前设备的宽度<br>initial-scale：初始的缩放比例（默认设置为1.0，即代表不缩放）<br>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）</p><ul><li>加载兼容文件JS<br>因为IE8既不支持HTML5也不支持CSS3 @media ，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果</li></ul><ul><li>设置IE渲染方式默认为最高(可选)  </li></ul><pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt;</code></pre><p>这段代码后面加了一个chrome=1，如果用户的电脑里安装了 chrome，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，如果没有安装，就显示IE最新的渲染模式。</p><ul><li>实例</li></ul><pre><code>@media screen and (min-width:300px) and (max-width:500px) {    /* CSS 代码 */}</code></pre><p>min-width:300px 的作用是当文档宽度不小于 300px 的时候就应用 {} 里的CSS代码块，即大于等于 300px<br>max-width:500px 的作用是当文档宽度不大于 500px 的时候就应用{} 里的CSS代码块，即小于等于 500px</p><p><a href="https://www.cnblogs.com/baiyii/p/6973437.html" target="_blank" rel="noopener">原文链接</a></p><h4 id="移动屏幕分辨率"><a href="#移动屏幕分辨率" class="headerlink" title="移动屏幕分辨率"></a>移动屏幕分辨率</h4><p><br>做移动端的页面，需要兼容各种型号，尺寸的设备。手机的话一般最小兼容到320*480，这是iphone4的屏幕分辨率。</p><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><ul><li><p>box-shadow：边框阴影</p><p>  box-shadow的常用属性值：<br>  h-shadow：必需。水平阴影的位置。允许负值<br>  v-shadow：必需。垂直阴影的位置。允许负值<br>  blur：可选。模糊距离<br>  spread：可选。阴影的尺寸。<br>  color：可选。阴影的颜色。请参阅 CSS 颜色值。<br>  inset：可选。将外部阴影 (outset) 改为内部阴影</p></li></ul><p><a href="http://web.jobbole.com/87938/" target="_blank" rel="noopener">探索 CSS3 中的 box-shadow 属性</a></p><ul><li><p>text-shadow：文本阴影</p><p>  text-shadow的常用属性值：<br>  h-shadow：必需。水平阴影的位置。允许负值<br>  v-shadow：必需。垂直阴影的位置。允许负值<br>  blur：可选。模糊的距离<br>  color：可选。阴影的颜色</p></li></ul><h4 id="border-collapse"><a href="#border-collapse" class="headerlink" title="border-collapse"></a>border-collapse</h4><p><br>border-collapse属性设置表格的边框是否被合并为一个单一的边框。 </p><p><strong>separate</strong>是默认值，边框会被分开，不会忽略border-spacing和empty-cells属性。 </p><p><strong>collapse</strong>如果可能，边框会合并为一个单一的边框，会忽略border-spacing和empty-cells属性。</p><h4 id="table细边框"><a href="#table细边框" class="headerlink" title="table细边框"></a>table细边框</h4><pre><code>table {    border-collapse: collapse;         border: none;     width: 100%;    &lt;!-- 可有可无，不影响效果，加上更美观 --&gt;}table td {    border: solid #CBCBCB 1px;}</code></pre><h4 id="li元素注意事项"><a href="#li元素注意事项" class="headerlink" title="li元素注意事项"></a>li元素注意事项</h4><ul><li><p>设置：<strong>display: inline-block;</strong> 之后，由于<strong>li的默认display: list-item(有小黑点);</strong> 所以相当于你改变了它的本质属性，小黑点会消失。</p></li><li><p>设置：<strong>float: left;</strong> 元素会从左至右排列；<strong>float: right;</strong> 元素会从右至左排列。</p></li><li><p><strong>list-style-position: inside;</strong><br>li元素的小黑点的显示位置是由list-style-position属性决定的，默认效果是outside，在li的外面，它不占用li的宽度；还可以设置成inside，在li的里面，会占用li的宽度。</p></li></ul><h4 id="去a下划线"><a href="#去a下划线" class="headerlink" title="去a下划线"></a>去a下划线</h4><pre><code>a {    text-decoration: none;}</code></pre><h4 id="button按钮常用样式"><a href="#button按钮常用样式" class="headerlink" title="button按钮常用样式"></a>button按钮常用样式</h4><ul><li>去掉按钮默认灰色边框</li></ul><pre><code>button {    border: none;}</code></pre><ul><li>按钮边角圆角度</li></ul><pre><code>button {     border-radius: 10px; }</code></pre><ul><li>按钮点击时去掉蓝色边框 </li></ul><pre><code>button {    outline: none;}</code></pre><h4 id="画倒三角"><a href="#画倒三角" class="headerlink" title="画倒三角"></a>画倒三角</h4><pre><code>&lt;div class=&quot;bg-black&quot;&gt;    &lt;span class=&quot;triangle-down&quot;&gt;    &lt;/span&gt;&lt;/div&gt;* {    margin: 0;    padding: 0;    box-sizing: border-box;}.bg-black {    width: 100%;    height: 50px;    text-align: center;}.triangle-down {    width: 0;    height: 0;    line-height: 45px;    border-color: transparent transparent rgba(37,74,108,1.00);    border-width: 0px 5px 8px 5px;    border-style: solid;}</code></pre><h4 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h4><p><br> opacity：不透明度，取值从0-1，越大越不透明，越小越透明。</p><p> 当向父元素的背景添加opacity属性，所有它的子元素也变为透明，若子元素为文本则不容易看清楚，如果不想使子元素透明，使用RGBA颜色值</p><h4 id="font-variant"><a href="#font-variant" class="headerlink" title="font-variant"></a>font-variant</h4><pre><code>font-variant:small-caps;&lt;!-- 浏览器会显示小型大写字母的字体 --&gt;</code></pre><h4 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h4><pre><code>none&lt;!-- 默认。定义带有小写字母和大写字母的标准的文本 --&gt;capitalize&lt;!-- 文本中的每个单词以大写字母开头 --&gt;uppercase&lt;!-- 定义仅有大写字母 --&gt;lowercase&lt;!--     定义无大写字母，仅有小写字母 --&gt;</code></pre><h4 id="overflow-wrap"><a href="#overflow-wrap" class="headerlink" title="overflow-wrap"></a>overflow-wrap</h4><p><br> 用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行(word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”)</p><pre><code>normal&lt;!-- 表示在正常的单词结束处换行 --&gt;break-word&lt;!-- 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行 --&gt;</code></pre><h4 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h4><pre><code>left：向左对齐right：向右对齐center：居中对齐justify：两端对齐</code></pre><p><br> 预知后事如何，请看下回分解…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- # css小记 --&gt;
&lt;!-- [toc] --&gt;
&lt;p&gt; 最近在公司做前端方面的工作，涉及到页面的编写。特此将刚刚知道的知识和碰过的坑整理一下，想到哪便写到哪。方便查阅。&lt;/p&gt;
&lt;p&gt; 写页面时注意兼容性，需要hack写法的就要多查阅不同浏览器版本的语法。也可以尝
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>动效设计</title>
    <link href="https://littleheng.gitee.io/2019/06/19/%E5%8A%A8%E6%95%88%E8%AE%BE%E8%AE%A1/"/>
    <id>https://littleheng.gitee.io/2019/06/19/动效设计/</id>
    <published>2019-06-19T09:39:54.000Z</published>
    <updated>2019-06-20T04:24:45.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>运用动态的图片传递信息和表达氛围</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>流畅过渡</li><li>高效反馈</li><li>增强操纵</li><li>帮助引导</li><li>升华体验</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>简洁适度，避免复杂繁琐</li><li>平衡开发成本</li><li>平衡性能和响应度，避免动效卡慢</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;运用动态的图片传递信息和表达氛围&lt;/p&gt;
&lt;h3 id=&quot;作用&quot;&gt;&lt;a href=&quot;#作用&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>百度前端学院-2017</title>
    <link href="https://littleheng.gitee.io/2019/06/04/%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E5%AD%A6%E9%99%A2-2017/"/>
    <id>https://littleheng.gitee.io/2019/06/04/百度前端学院-2017/</id>
    <published>2019-06-04T03:03:09.000Z</published>
    <updated>2019-06-04T03:24:25.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小薇学院"><a href="#小薇学院" class="headerlink" title="小薇学院"></a>小薇学院</h3><hr><p><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task01/demo.html" target="_blank" rel="noopener">任务一：零基础HTML编码</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task02/demo.html" target="_blank" rel="noopener">任务二：零基础HTML及CSS编码（一）</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task03/demo.html" target="_blank" rel="noopener">任务三：三栏式布局</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task04/demo.html" target="_blank" rel="noopener">任务四：定位和居中问题</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task05/demo.html" target="_blank" rel="noopener">任务五：零基础HTML及CSS编码（二）</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task06/demo.html" target="_blank" rel="noopener">任务六：通过HTML及CSS模拟报纸排版</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task07/demo.html" target="_blank" rel="noopener">任务七：实现常见的技术产品官网的页面架构及样式布局</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小薇学院&quot;&gt;&lt;a href=&quot;#小薇学院&quot; class=&quot;headerlink&quot; title=&quot;小薇学院&quot;&gt;&lt;/a&gt;小薇学院&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://littleheng.github.io/ife_baidu_2017/xiao
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>队列和堆栈</title>
    <link href="https://littleheng.gitee.io/2019/06/01/%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%E6%A0%88/"/>
    <id>https://littleheng.gitee.io/2019/06/01/队列和堆栈/</id>
    <published>2019-06-01T09:45:56.000Z</published>
    <updated>2019-06-01T09:48:04.418Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列-queue-：先进先出数据结构-FIFO：first-in-first-out"><a href="#队列-queue-：先进先出数据结构-FIFO：first-in-first-out" class="headerlink" title="队列(queue)：先进先出数据结构(FIFO：first-in-first-out)"></a>队列(queue)：先进先出数据结构(FIFO：first-in-first-out)</h3><hr><h4 id="先进先出的数据结构"><a href="#先进先出的数据结构" class="headerlink" title="先进先出的数据结构"></a>先进先出的数据结构</h4><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/03/screen-shot-2018-05-03-at-151021.png" alt="&#39;&#39;"></p><p> 在FIFO数据结构中，添加到队列中的第一个元素将首先被处理。队列是典型的FIFO数据结构。insert操作也称为enqueue(入队)，新元素始终是被添加到队列的结尾。删除操作称为dequeue(出列)。你只被允许移除队列的第一个元素。</p><h4 id="队列-实现"><a href="#队列-实现" class="headerlink" title="队列-实现"></a>队列-实现</h4><blockquote><pre><code>package com.learn.dao;</code></pre></blockquote><pre><code>import java.util.ArrayList;import java.util.List;public class MyQueue {    private List&lt;Integer&gt; data;    private int p_start;    public MyQueue() {        data = new ArrayList&lt;Integer&gt;();        p_start = 0;    }    public boolean enqueue(int x) {        data.add(x);        return true;    }    public boolean dequeue() {        if (isEmpty()) {            return false;        }        p_start++;        return true;    }    public int front() {        return data.get(p_start);    }    public boolean isEmpty() {        return p_start &gt;= data.size();    }    public static void main(String[] args) {        MyQueue myQueue = new MyQueue();        myQueue.enqueue(3);        myQueue.enqueue(5);        if(!myQueue.isEmpty()) {            System.out.println(myQueue.front());        }        myQueue.dequeue();        if(!myQueue.isEmpty()) {            System.out.println(myQueue.front());        }        myQueue.dequeue();        if(!myQueue.isEmpty()) {            System.out.println(myQueue.front());        }    }}</code></pre><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><em>缺点</em></h5><p>上面的实现很简单，但在某些情况下效率很低。随着起点指针的移动，会浪费越来越多的空间。如果我们空间有限时，这种实现是无法接受的。</p><h4 id="设计循环队列"><a href="#设计循环队列" class="headerlink" title="设计循环队列"></a>设计循环队列</h4><p>循环队列是线性数据结构，其中基于FIFO原理执行操作、，并且最后位置连接回第一位置以形成圆。它也被称为“环形缓冲区”。</p><p>循环队列的一个好处是我们可以利用队列前面的空格。在正常队列中，一旦队列变满，即使队列前面有空格，我们也无法插入下一个元素。但是使用循环队列，我们可以使用空下来的空间存储新值。</p><h5 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h5><blockquote><pre><code>package com.learn.dao;</code></pre></blockquote><pre><code>import java.util.ArrayList;import java.util.List;public class MyCircularQueue {    private List&lt;Integer&gt; data;    private int p_start;    private int p_end;    private int dataSize;    public MyCircularQueue(int k) {        data = new ArrayList&lt;Integer&gt;(k);        dataSize = k;        p_start = 0;        p_end = -1;    }    public boolean enqueue(int x) {        if(isFull()) {            return false;        }        if((p_end + 1) &gt;= dataSize) {            p_end = -1;        }        data.add(p_end + 1, x);        p_end++;        return true;    }    public boolean dequeue() {        if (isEmpty()) {            return false;        }        data.remove(p_start);        p_start++;        if(p_start &gt;= dataSize) {            p_start = 0;        }        return true;    }    public int front() {        if(isEmpty()) {            return -1;        }        return data.get(p_start);    }    public int rear() {        if(isEmpty()) {            return -1;        }        return data.get(p_end);        }    public boolean isEmpty() {        int size = data.size();        if(size &lt;= 0) {            return true;        }else{            return false;        }    }    public boolean isFull() {        int size = data.size();        if(size &gt;= dataSize) {            return true;        }else{            return false;        }    }    public static void main(String[] args) {        MyCircularQueue myQueue = new MyCircularQueue(3);        System.out.println(myQueue.enqueue(1));        System.out.println(myQueue.enqueue(2));        System.out.println(myQueue.enqueue(3));        System.out.println(myQueue.enqueue(4));        System.out.println(myQueue.rear());        System.out.println(myQueue.isFull());        System.out.println(myQueue.dequeue());        System.out.println(myQueue.enqueue(4));        System.out.println(myQueue.rear());    }}</code></pre><h5 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h5><blockquote><pre><code>class MyCircularQueue {</code></pre></blockquote><pre><code>    private int[] data;    private int head;    private int tail;    private int size;    /** Initialize your data structure here. Set the size of the queue to be k. */    public MyCircularQueue(int k) {        data = new int[k];        head = -1;        tail = -1;        size = k;    }    /** Insert an element into the circular queue. Return true if the operation is successful. */    public boolean enQueue(int value) {        if (isFull() == true) {            return false;        }        if (isEmpty() == true) {            head = 0;        }        tail = (tail + 1) % size;        data[tail] = value;        return true;    }    /** Delete an element from the circular queue. Return true if the operation is successful. */    public boolean deQueue() {        if (isEmpty() == true) {            return false;        }        if (head == tail) {            head = -1;            tail = -1;            return true;        }        head = (head + 1) % size;        return true;    }    /** Get the front item from the queue. */    public int Front() {        if (isEmpty() == true) {            return -1;        }        return data[head];    }    /** Get the last item from the queue. */    public int Rear() {        if (isEmpty() == true) {            return -1;        }        return data[tail];    }    /** Checks whether the circular queue is empty or not. */    public boolean isEmpty() {        return head == -1;    }    /** Checks whether the circular queue is full or not. */    public boolean isFull() {        return ((tail + 1) % size) == head;    }}</code></pre><h3 id="队列和BFS"><a href="#队列和BFS" class="headerlink" title="队列和BFS"></a>队列和BFS</h3><p>广度优先搜索算法(Breadth-first Search)的一个常见应用是找到从根节点到目标节点的最短路径。</p><h4 id="BFS-模板"><a href="#BFS-模板" class="headerlink" title="BFS-模板"></a>BFS-模板</h4><blockquote><pre><code>/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) {    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    // BFS    while (queue is not empty) {        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) {            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) {                add next to queue;            }            remove the first node from queue;        }    }    return -1;          // there is no path from root to target}</code></pre></blockquote><h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><p>给定’1’s(土地)和’0’s(水)的2d网格图，计算岛屿的数量。岛被水包围，通过水平或垂直连接相邻的土地而形成。你可以假设网格的所有四个边都被水包围。</p><h5 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h5><blockquote><p>  输入：<br>    11110<br>    11010<br>    11000<br>    00000</p></blockquote><pre><code>输出：1</code></pre><h5 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h5><blockquote><p>  输入：<br>    11000<br>    11000<br>    00100<br>    00011</p></blockquote><pre><code>输出：3</code></pre><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><blockquote><pre><code>package com.learn.dao;</code></pre></blockquote><pre><code>public class NumIsland {    private char[][] gird;    private int rols;    private int cols;    private int count;    public NumIsland(char[][] tempGird) {        gird = tempGird;        count = 0;    }    public int calcIslandCount() {        rols = gird.length;        if(rols &lt;= 0){            return 0;        }        for(int i = 0; i &lt; rols; i++) {            cols = gird[i].length;            for(int j = 0; j &lt; cols; j++) {                if(gird[i][j] == &apos;1&apos;) {                    count++;                    doSearch(gird, i, j, rols, cols);                }            }        }        return count;    }    private void doSearch(char[][] tempGird, int i, int j, int rols, int cols) {        if(i &lt; 0 || j &lt; 0 || i &gt;= rols || j &gt;= cols) {            return;        }        if(gird[i][j] != &apos;1&apos;) {            return;        }        gird[i][j] = &apos;0&apos;;        doSearch(tempGird, i + 1, j, rols, cols);        doSearch(tempGird, i - 1, j, rols, cols);        doSearch(tempGird, i, j + 1, rols, cols);        doSearch(tempGird, i, j - 1, rols, cols);    }    public static void main(String[] args) {        char[][] grid = {{'1','1','1','1','0','0'},{'1','1','1','1','0','1'},{'1','1','1','1','0','0'},{'1','1','1','1','0','0'}};        NumIsland numIsland = new NumIsland(grid);        System.out.println(numIsland.calcIslandCount());    }}</code></pre><h4 id="Open-the-Lock-开锁"><a href="#Open-the-Lock-开锁" class="headerlink" title="Open the Lock 开锁"></a>Open the Lock 开锁</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;队列-queue-：先进先出数据结构-FIFO：first-in-first-out&quot;&gt;&lt;a href=&quot;#队列-queue-：先进先出数据结构-FIFO：first-in-first-out&quot; class=&quot;headerlink&quot; title=&quot;队列(queue
      
    
    </summary>
    
    
  </entry>
  
</feed>
