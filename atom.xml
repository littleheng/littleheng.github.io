<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zahra</title>
  
  <subtitle>简单的事情坚持做，重复做。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://littleheng.gitee.io/"/>
  <updated>2019-09-21T02:56:28.368Z</updated>
  <id>https://littleheng.gitee.io/</id>
  
  <author>
    <name>zahra</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue父子组件数据传递</title>
    <link href="https://littleheng.gitee.io/2019/09/21/vue%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%92/"/>
    <id>https://littleheng.gitee.io/2019/09/21/vue父子组件数据传递/</id>
    <published>2019-09-21T02:50:43.000Z</published>
    <updated>2019-09-21T02:56:28.368Z</updated>
    
    <content type="html"><![CDATA[<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><h4 id="父组件向子组件传递数据"><a href="#父组件向子组件传递数据" class="headerlink" title="父组件向子组件传递数据"></a>父组件向子组件传递数据</h4><blockquote><p>首先定义子组件时在props对象中先把需要父组件传入的数据对象先定义好，当在父组件中使用这个子组件并传值时，子组件的props中的相应属性会接收到这个值，子组件就可以使用相应的props中的属性值。值得注意的是：props中的属性只允许在父组件中修改，不允许在子组件中修改，是为了避免数据发生混乱。不过可以通过watch监听到props中属性值的修改。</p></blockquote><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//  子组件</span><br><span class="line">  props: &#123;</span><br><span class="line">    visiable: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;,</span><br><span class="line">    isMultiple: &#123;</span><br><span class="line">      type: Boolean,</span><br><span class="line">      default: false</span><br><span class="line">    &#125;,</span><br><span class="line">    title: &#123;</span><br><span class="line">      type: String,</span><br><span class="line">      default: &quot;客户列表&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//  父组件中引用子组件</span><br><span class="line">&lt;customer-list :visiable=&quot;customerListVisible&quot; :isMultiple=&quot;false&quot; :title=&quot;&apos;请选择受访客户&apos;&quot;&gt;&lt;/customer-list&gt;</span><br></pre></td></tr></table></figure><h4 id="子组件向父组件传递数据"><a href="#子组件向父组件传递数据" class="headerlink" title="子组件向父组件传递数据"></a>子组件向父组件传递数据</h4><p>有时候当父组件需要获取到子组件的数据时，有两种方式可以实现。其中一种是通过<strong>ref</strong>实现；另一种是通过$emit实现。</p><hr><blockquote><p>使用ref时，只需要在引用子组件时用一个临时属性去对接子组件的ref标签，就可以在父组件中通过（this.$refs.临时属性.需要获取的属性名称）获取到子组件中data中的对应属性值。</p></blockquote><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//  子组件</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      multipleSelection: []</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">//  父组件中引用子组件</span><br><span class="line">&lt;customer-list ref=&quot;getSelectData&quot;&gt;&lt;/customer-list&gt;</span><br><span class="line"></span><br><span class="line">//  父组件中获取子组件data数据的vue代码</span><br><span class="line">data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        getSelectData: []</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;,</span><br><span class="line">created() &#123;</span><br><span class="line">    const customerList = this.$refs.getSelectData.multipleSelection;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><hr><blockquote><p>如果想使用$emit获取子组件的数据，则需要在定义子组件时在需要的时候触发$emit事件。$emit事件触发时可以指定在引用子组件时被触发的事件名称以及参数。然后在引用子组件时用一个自定义事件绑定被触发的事件，该自定义事件就能得到子组件传递的参数（可多个参数）。</p></blockquote><p>实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">//  子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input type=&apos;file&apos; @change=&quot;changeUrl&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeUrl(e) &#123;</span><br><span class="line">            this.$emit(&apos;changeUrl&apos;, e.currentTarget.files[0].path)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;uploadImg @changeUrl=&quot;getUrl&quot;&gt;&lt;/uploadImg&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        getUrl(path) &#123;</span><br><span class="line">            //  这个就是你要的path，并且会双向绑定</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>补充</strong></p><p>如果子组件的数据是个对象，当对象的某个属性值变化时，可以将此属性-值绑定为响应式数据，这样父组件中对应的对象也会变化，得到最新的值。</p><p>实例： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">//  子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;input :key=&quot;item.name&quot; v-for=&quot;item in dataItems&quot; :name=&quot;item.name&quot; :value=&quot;item.value&quot; type=&apos;text&apos; @change=&quot;changeValue(val, item)&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    props: &#123;</span><br><span class="line">      dataItems: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        defalt: [&#123;</span><br><span class="line">            name: &apos;age&apos;,</span><br><span class="line">            value: &apos;12&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            name: &apos;remark&apos;,</span><br><span class="line">            value: &apos;测试&apos;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        changeValue(val, item) &#123;</span><br><span class="line">            this.$set(this.dataItems, item.name, val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//  父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;form-data :dataItems=&quot;dataItems&quot;&gt;&lt;/form-data&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            dataItems: [],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        dataItems: &#123;</span><br><span class="line">            handler(newValue) &#123;</span><br><span class="line">                console.log(newValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;组件化&quot;&gt;&lt;a href=&quot;#组件化&quot; class=&quot;headerlink&quot; title=&quot;组件化&quot;&gt;&lt;/a&gt;组件化&lt;/h3&gt;&lt;h4 id=&quot;父组件向子组件传递数据&quot;&gt;&lt;a href=&quot;#父组件向子组件传递数据&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CSS随记</title>
    <link href="https://littleheng.gitee.io/2019/06/20/CSS%E9%9A%8F%E8%AE%B0/"/>
    <id>https://littleheng.gitee.io/2019/06/20/CSS随记/</id>
    <published>2019-06-20T02:50:11.000Z</published>
    <updated>2019-06-20T04:17:19.528Z</updated>
    
    <content type="html"><![CDATA[<!-- # css小记 --><!-- [toc] --><p> 最近在公司做前端方面的工作，涉及到页面的编写。特此将刚刚知道的知识和碰过的坑整理一下，想到哪便写到哪。方便查阅。</p><p> 写页面时注意兼容性，需要hack写法的就要多查阅不同浏览器版本的语法。也可以尝试新的技术。比如less、sass、stylus等。</p><hr><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul><li>编写页面之前，记得初始化背景画布，因为浏览器先是加载DOM树，然后再将元素的默认属性画上去。有一些元素的默认属性会影响页面布局和定位。例如ul有默认的换行（外边距）和左内边距。</li></ul><ul><li><p>页面初始化需要的三种样式：</p><ul><li>重置样式(reset)：html的许多标签是有默认样式的。需要将它们初始化。</li><li>公共样式(common)：公用的，可重复使用的样式。</li><li>独立样式：相对于某个页面单独使用的样式。</li></ul></li></ul><pre><code>* {     margin: 0;    padding: 0px;  &lt;!-- 值为1个时对应所有；值为2个时对应上下、左右；值为3个时对应上、左右、下；值为4个时分别对应上、右、下、左。  --&gt;    -webkit-box-sizing: border-box;    -moz-box-sizing: border-box;      -ms-box-sizing: border-box;      -o-box-sizing: border-box;      box-sizing: border-box;  }body {    background-color: #f8f8fd;      font-size: 0.875rem;      /*  max-width: 10rem;  */  }</code></pre><p> 可以设置默认的<strong>body背景色</strong>，元素之间切割有距离时露出背景色挺方便。</p><h4 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h4><p><br> 使用<strong>rem</strong>做移动端网页，font-size应初始化在html根元素上，一般浏览器默认值为<strong>16px = 1rem</strong>。如果根元素为16px，那么每增加2px会增加0.125rem。每增加10px会增加0.625rem。(google浏览器默认中文最小字体为12px。&lt;12一律显示为12px大小。但允许设置为0。最小字体限制数可以在浏览器的设置中更改)</p><h4 id="max-width、min-width"><a href="#max-width、min-width" class="headerlink" title="max-width、min-width"></a>max-width、min-width</h4><p><br> 使用<strong>max-width</strong>属性时，要小心，它可以让浏览器更好的处理小窗口的情况。这点在移动设备上尤为重要。我记得我使用了两次，第一次很成功，第二次页面就缩小了一半、、、暂时不知道为啥。使用min-width时，如果最小宽度大于可视宽度，会出现滚动条；当可视宽度变化为小于或等于最小宽度时，页面内容不会随宽度的缩小而缩小。可能部分内容需要移动滚动条才可查看。</p><h4 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h4><p><br> 在我的印象中，一个简单的应用是块级元素（display: block）可以使用此属性轻松居中。简单又很酷。</p><pre><code>div {    display: block;    margin: 0 auto;    max-width: 600px;    /*    当div的宽度大于可视区的宽度时，浏览器会显示一个水平滚动条来容纳页面。用这个属性可以避免这种情况。更酷。    */  }</code></pre><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><pre><code>box-sizing: border-box  (内边距、边框宽度在设置的元素尺寸之内。盒子尺寸=设置的元素尺寸);   box-sizing: content-box  (内边距、边框宽度、外边距在设置的元素尺寸的外围。盒子实际尺寸&gt;=设置的元素尺寸);</code></pre><blockquote><p>注：为了向前兼容老版本的浏览器，某些属性会加前缀<br>  <strong>-webkit-</strong>：google,safari私有属性;<br>  <strong>-moz-</strong>：firefox私有属性;<br>  <strong>-ms-</strong>：internet explorer私有属性;<br>  <strong>-o-</strong>：opera私有属性;</p></blockquote><pre><code>-webkit-box-sizing: border-box;-moz-box-sizing: border-box;-ms-box-sizing: border-box;-o-box-sizing: border-box;box-sizing: border-box;</code></pre><hr><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><p><br></p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p> <br> 弹性布局/伸缩盒子。设为flex布局后，子元素的float、clear、vertical-align属性将失效。</p><pre><code>.flex {    display: -webkit-flex;    display: flex;  }  /*  webkit内核的浏览器，必须加上-webkit-前缀  */  .div1 {    -moz-box-flex: 1.0;      -webkit-box-flex: 1.0;    box-flex: 1.0;  }.div2 {    -moz-box-flex: 2.0;    -webkit-box-flex: 2.0;    box-flex: 2.0;  }</code></pre><p><br>      </p><h4 id="box"><a href="#box" class="headerlink" title="box"></a>box</h4><p> <br> box-flex主要让子容器针对父容器的宽度按一定规则进行划分</p><h5 id="box属性"><a href="#box属性" class="headerlink" title="box属性"></a>box属性</h5><pre><code>box-orient | box-direction | box-align | box-pack | box-lines</code></pre><ul><li>box-orient<br>用来确定父容器里子容器的排列方式，是水平还是垂直。</li></ul><pre><code>horizontal | vertical | inline-axis | block-axis | inherit</code></pre><p> 给box设置horizontal或inline-axis属性其效果似乎表现一致，都可将子容器水平排列</p><p> 如果父容器选择horizontal或inline-axis属性对子容器进行水平排列，其是对父容器的宽度进行分配划分。此时如果父容器定义了高度值，其子容器的高度值设置则无效状态，所有子容器的高度等于父容器的高度值；如果父容器不设置高度值，其子容器的高度值才有效并且取最大高度值的子容器的高度。</p><p> 给box设置vertical或block-axis属性(此属性是默认值)其效果似乎表现一致，都可将子容器垂直排列</p><p> 如果父容器选择vertical或block-axis属性对子容器进行垂直排列，其是对父容器的高度进行分配划分。此时如果父容器<br>定义了宽度值，其子容器的宽度值设置则无效状态；如果父容器不设置宽度值，其子容器的宽度值才有效并且取最大宽度值的子容器的宽度。</p><p> inherit属性则是让子容器继承父容器的相关属性</p><ul><li>box-direction<br>用来确定父容器里的子容器排列顺序</li></ul><pre><code>normal | reverse | inherit&lt;!-- normal是默认值，按照HTML文档里结构的先后顺序依次展示 --&gt;&lt;!-- reverse表示反转 --&gt;</code></pre><ul><li>box-align<br>表示父容器里面子容器的垂直对齐方式</li></ul><pre><code>start | end | center | baseline | stretch&lt;!-- start：在box-align表示居顶对齐 --&gt;&lt;!-- end：在box-align表示居底对齐 --&gt;&lt;!-- center：在box-align表示居中对齐 --&gt;&lt;!-- stretch：在box-align表示拉伸，拉伸到与父容器等高 --&gt;</code></pre><ul><li>box-pack<br>表示父容器里面子容器的水平对齐方式</li></ul><pre><code>start | end | center | justify&lt;!-- start：在box-pack表示水平居左对齐 --&gt;&lt;!-- end：在box-pack表示水平居右对齐 --&gt;&lt;!-- center：在box-pack表示水平居中对齐 --&gt;&lt;!-- justify:在box-pack表示水平等分父容器宽度 --&gt;</code></pre><p><a href="https://www.cnblogs.com/leejersey/p/3795885.html" target="_blank" rel="noopener">移动web开发实践-css3（1）盒模型display:-webkit-box;的使用</a></p><p><br></p><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p><br> 定位和z-index配合使用时，可以将元素分为不同的层级。</p><ul><li>常用的属性值 <ul><li>relative：相对定位</li><li>absolute：绝对定位</li><li>fixed：固定定位</li></ul></li></ul><h5 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h5><p><br> 默认使用相对定位时，元素是相对于原有位置进行移动。移动完成后，它依然存在于原来的文档流中，所以在原有位置会有一段空白，如果不注意的话，就无法得到自己想要的效果。这时可以试试将元素的外边距设为负数看能不能达到相同的效果。</p><pre><code>&lt;!-- 使用相对定位移动元素 --&gt;.cover {    position: relative;    top: -10px; &lt;!-- 会在原有位置留有空白 --&gt;}&lt;!-- 使用margin实现同样的效果 --&gt;.cover {    margin-top: -10px;    &lt;!-- 不会留有空白 --&gt;}</code></pre><h5 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h5><p><br> 使用绝对定位时，场景比较多的是先将父元素进行相对定位（relative），再将子元素设置为绝对定位（absolute），再根据实际情况上下左右调整距离。absolute定位的元素会脱离文档流，如果父元素里面没有其他在文档流中的元素时，父元素会塌陷。</p><pre><code>.father {    postion: relative}.son {    postion: absolute;    top: 0;    bottom: 0;    left: 0;    right: 0;    &lt;!-- son元素位置无变化，在父元素的左上角 --&gt;}</code></pre><h5 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h5><p><br> 固定定位可以将元素固定在某一个位置，不随滚动条的滚动而滚动，可以简单视为相对于可视区去定位。</p><pre><code>&lt;!-- 实现移动端页面底部菜单浮动 --&gt;.footer-menu {    width: 100%;    position: fixed;    bottom: 0;  }</code></pre><p><a href="http://ife.baidu.com/note/detail/id/662" target="_blank" rel="noopener">理解绝对定位</a></p><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p><br> 这是一个神奇的属性，有非常多的属性值。对布局很有用。不过我只掌握了常用的几种。（inline，inline-block，block）</p><ul><li><p><strong>inline</strong><br>显示为内联元素，不可设置元素宽高、垂直居中，内边距只对左、右、下起作用，外边距只对左、右起作用。可设置文本对齐。<br>不过使用绝对定位/浮动后，inline元素变为inline-block元素。以上的效果都有效。</p></li><li><p><strong>inline-block</strong><br>这是我使用的比较多的一个值，也是我认为比较酷的一个选项。我经常使用它来将多个li元素排列为一行。它同时具备内联元素、块级元素的特点。（内联块状元素）它有如下特点：<br>a. 和其他元素都在一行上<br>b. 元素的宽、高、行高以及顶和底边距都可以设置<br>c. vertical-align属性会影响到inline-block元素    ，你可能会把它的值设置为top<br>d. 你需要设置每一列的宽度<br>e. 如果HTML源代码中元素之间有空格，那么列与列    之间会产生空隙</p></li></ul><ul><li><strong>block</strong><br>块级元素，可设置宽、高、内外边距、行高、、、独占一行。</li></ul><h4 id="百分比宽度"><a href="#百分比宽度" class="headerlink" title="百分比宽度"></a>百分比宽度</h4><p><br> 百分比是一种相对于包含块的计量单位。这个简直不要太爽。我经常利用它加inline-block实现li元素多行多列的布局。</p><pre><code>父元素  div {    width: 100%;    background-color: #fff;  }  li {    /*    宽度随需求而定，24%相当于一行显示4列    */    width: 24%;    display: inline-block;  /*这个是关键  */    text-align: center;    /*可以让li内的元素居中 */    padding: 0.3125rem 03125rem;    /*可以使布局更美观 */    position: relative;    /*与子元素的绝对定位使用，你让它向东绝不会向西。 */  }或者li {    width: 25%;      float: left;}</code></pre><h4 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h4><p><br> 经常出现一个情况，子元素全部浮动起来了，然后父元素没有被撑起来。曾经让我很抠脑壳。后来终于发现了两种方法解决这个顽疾。  </p><ul><li><p>在父元素中再添加一个子元素，设置子元素不透明度为0（opacity: 0）。然后子元素再clear:    both。完美结局。  </p></li><li><p>但是我更喜欢第二种，不用添加元素。使用伪类实现。  </p></li></ul><pre><code>img(浮动的元素或父元素):after,img:before {      content: &apos;&apos;,      clear: both;}</code></pre><p>经常使用的清除浮动的类：</p><pre><code>.clearfix:before,.clearfix:after {    content: &apos;&apos;;    display: table;}.clearfix:after {   &lt;!-- 伪类与前面的冒号不能有空格，有空格会失效 --&gt;    clear: both;}</code></pre><p><a href="http://zh.learnlayout.com/toc.html" title="点击吧，超实用" target="_blank" rel="noopener">这里</a>有网页布局的许多知识。曾经帮助我实现css布局入门。</p><hr><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><br></p><h4 id="一行文本省略"><a href="#一行文本省略" class="headerlink" title="一行文本省略"></a>一行文本省略</h4><pre><code>overflow: hidden;text-overflow: ellipsis;    //  ...white-space: nowrap;    </code></pre><p>多行可以加上line-height和display配合使用。(貌似还有height)</p><h4 id="img和span行内对齐"><a href="#img和span行内对齐" class="headerlink" title="img和span行内对齐"></a>img和span行内对齐</h4><p><br> 只能说我太笨了，某天遇到这个坑时，纠结了半天，左调调右调调，就是对不齐，抠脑壳。最后发现是如此的简单。  </p><pre><code>img {      width: 1.25rem;      height: 1.25rem;      vertical-align: middle;  }  span {      display: inline-block;      vertical-align: middle;  }  </code></pre><p>  <em>注意：两个元素必须都是inline-block元素，并且img一定要设置宽、高。 </em><br><br>  </p><h4 id="media-css3"><a href="#media-css3" class="headerlink" title="@media(css3)"></a>@media(css3)</h4><p><br><br> 1、 语法</p><pre><code>@media mediaType and|not|only (media feature) {      /*CSS-Code;*/  }</code></pre><p> 媒体类型（mediaType ）：常用</p><pre><code>all    用于所有设备print    用于打印机和打印预览screen    用于电脑屏幕，平板电脑，智能手机等。speech    应用于屏幕阅读器等发声设备</code></pre><p>媒体功能（media feature）：常用</p><pre><code>max-width    定义输出设备中的页面最大可见区域宽度min-width    定义输出设备中的页面最小可见区域宽度</code></pre><p> 2、 准备工作  </p><ul><li>设置Meta标签</li></ul><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;</code></pre><p>width = device-width：宽度等于当前设备的宽度<br>initial-scale：初始的缩放比例（默认设置为1.0，即代表不缩放）<br>user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面）</p><ul><li>加载兼容文件JS<br>因为IE8既不支持HTML5也不支持CSS3 @media ，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果</li></ul><ul><li>设置IE渲染方式默认为最高(可选)  </li></ul><pre><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt;</code></pre><p>这段代码后面加了一个chrome=1，如果用户的电脑里安装了 chrome，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，如果没有安装，就显示IE最新的渲染模式。</p><ul><li>实例</li></ul><pre><code>@media screen and (min-width:300px) and (max-width:500px) {    /* CSS 代码 */}</code></pre><p>min-width:300px 的作用是当文档宽度不小于 300px 的时候就应用 {} 里的CSS代码块，即大于等于 300px<br>max-width:500px 的作用是当文档宽度不大于 500px 的时候就应用{} 里的CSS代码块，即小于等于 500px</p><p><a href="https://www.cnblogs.com/baiyii/p/6973437.html" target="_blank" rel="noopener">原文链接</a></p><h4 id="移动屏幕分辨率"><a href="#移动屏幕分辨率" class="headerlink" title="移动屏幕分辨率"></a>移动屏幕分辨率</h4><p><br>做移动端的页面，需要兼容各种型号，尺寸的设备。手机的话一般最小兼容到320*480，这是iphone4的屏幕分辨率。</p><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><ul><li><p>box-shadow：边框阴影</p><p>  box-shadow的常用属性值：<br>  h-shadow：必需。水平阴影的位置。允许负值<br>  v-shadow：必需。垂直阴影的位置。允许负值<br>  blur：可选。模糊距离<br>  spread：可选。阴影的尺寸。<br>  color：可选。阴影的颜色。请参阅 CSS 颜色值。<br>  inset：可选。将外部阴影 (outset) 改为内部阴影</p></li></ul><p><a href="http://web.jobbole.com/87938/" target="_blank" rel="noopener">探索 CSS3 中的 box-shadow 属性</a></p><ul><li><p>text-shadow：文本阴影</p><p>  text-shadow的常用属性值：<br>  h-shadow：必需。水平阴影的位置。允许负值<br>  v-shadow：必需。垂直阴影的位置。允许负值<br>  blur：可选。模糊的距离<br>  color：可选。阴影的颜色</p></li></ul><h4 id="border-collapse"><a href="#border-collapse" class="headerlink" title="border-collapse"></a>border-collapse</h4><p><br>border-collapse属性设置表格的边框是否被合并为一个单一的边框。 </p><p><strong>separate</strong>是默认值，边框会被分开，不会忽略border-spacing和empty-cells属性。 </p><p><strong>collapse</strong>如果可能，边框会合并为一个单一的边框，会忽略border-spacing和empty-cells属性。</p><h4 id="table细边框"><a href="#table细边框" class="headerlink" title="table细边框"></a>table细边框</h4><pre><code>table {    border-collapse: collapse;         border: none;     width: 100%;    &lt;!-- 可有可无，不影响效果，加上更美观 --&gt;}table td {    border: solid #CBCBCB 1px;}</code></pre><h4 id="li元素注意事项"><a href="#li元素注意事项" class="headerlink" title="li元素注意事项"></a>li元素注意事项</h4><ul><li><p>设置：<strong>display: inline-block;</strong> 之后，由于<strong>li的默认display: list-item(有小黑点);</strong> 所以相当于你改变了它的本质属性，小黑点会消失。</p></li><li><p>设置：<strong>float: left;</strong> 元素会从左至右排列；<strong>float: right;</strong> 元素会从右至左排列。</p></li><li><p><strong>list-style-position: inside;</strong><br>li元素的小黑点的显示位置是由list-style-position属性决定的，默认效果是outside，在li的外面，它不占用li的宽度；还可以设置成inside，在li的里面，会占用li的宽度。</p></li></ul><h4 id="去a下划线"><a href="#去a下划线" class="headerlink" title="去a下划线"></a>去a下划线</h4><pre><code>a {    text-decoration: none;}</code></pre><h4 id="button按钮常用样式"><a href="#button按钮常用样式" class="headerlink" title="button按钮常用样式"></a>button按钮常用样式</h4><ul><li>去掉按钮默认灰色边框</li></ul><pre><code>button {    border: none;}</code></pre><ul><li>按钮边角圆角度</li></ul><pre><code>button {     border-radius: 10px; }</code></pre><ul><li>按钮点击时去掉蓝色边框 </li></ul><pre><code>button {    outline: none;}</code></pre><h4 id="画倒三角"><a href="#画倒三角" class="headerlink" title="画倒三角"></a>画倒三角</h4><pre><code>&lt;div class=&quot;bg-black&quot;&gt;    &lt;span class=&quot;triangle-down&quot;&gt;    &lt;/span&gt;&lt;/div&gt;* {    margin: 0;    padding: 0;    box-sizing: border-box;}.bg-black {    width: 100%;    height: 50px;    text-align: center;}.triangle-down {    width: 0;    height: 0;    line-height: 45px;    border-color: transparent transparent rgba(37,74,108,1.00);    border-width: 0px 5px 8px 5px;    border-style: solid;}</code></pre><h4 id="opacity"><a href="#opacity" class="headerlink" title="opacity"></a>opacity</h4><p><br> opacity：不透明度，取值从0-1，越大越不透明，越小越透明。</p><p> 当向父元素的背景添加opacity属性，所有它的子元素也变为透明，若子元素为文本则不容易看清楚，如果不想使子元素透明，使用RGBA颜色值</p><h4 id="font-variant"><a href="#font-variant" class="headerlink" title="font-variant"></a>font-variant</h4><pre><code>font-variant:small-caps;&lt;!-- 浏览器会显示小型大写字母的字体 --&gt;</code></pre><h4 id="text-transform"><a href="#text-transform" class="headerlink" title="text-transform"></a>text-transform</h4><pre><code>none&lt;!-- 默认。定义带有小写字母和大写字母的标准的文本 --&gt;capitalize&lt;!-- 文本中的每个单词以大写字母开头 --&gt;uppercase&lt;!-- 定义仅有大写字母 --&gt;lowercase&lt;!--     定义无大写字母，仅有小写字母 --&gt;</code></pre><h4 id="overflow-wrap"><a href="#overflow-wrap" class="headerlink" title="overflow-wrap"></a>overflow-wrap</h4><p><br> 用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行(word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”)</p><pre><code>normal&lt;!-- 表示在正常的单词结束处换行 --&gt;break-word&lt;!-- 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行 --&gt;</code></pre><h4 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h4><pre><code>left：向左对齐right：向右对齐center：居中对齐justify：两端对齐</code></pre><p><br> 预知后事如何，请看下回分解…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- # css小记 --&gt;
&lt;!-- [toc] --&gt;
&lt;p&gt; 最近在公司做前端方面的工作，涉及到页面的编写。特此将刚刚知道的知识和碰过的坑整理一下，想到哪便写到哪。方便查阅。&lt;/p&gt;
&lt;p&gt; 写页面时注意兼容性，需要hack写法的就要多查阅不同浏览器版本的语法。也可以尝
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>百度前端学院-2017</title>
    <link href="https://littleheng.gitee.io/2019/06/04/%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E5%AD%A6%E9%99%A2-2017/"/>
    <id>https://littleheng.gitee.io/2019/06/04/百度前端学院-2017/</id>
    <published>2019-06-04T03:03:09.000Z</published>
    <updated>2019-06-04T03:24:25.305Z</updated>
    
    <content type="html"><![CDATA[<h3 id="小薇学院"><a href="#小薇学院" class="headerlink" title="小薇学院"></a>小薇学院</h3><hr><p><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task01/demo.html" target="_blank" rel="noopener">任务一：零基础HTML编码</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task02/demo.html" target="_blank" rel="noopener">任务二：零基础HTML及CSS编码（一）</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task03/demo.html" target="_blank" rel="noopener">任务三：三栏式布局</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task04/demo.html" target="_blank" rel="noopener">任务四：定位和居中问题</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task05/demo.html" target="_blank" rel="noopener">任务五：零基础HTML及CSS编码（二）</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task06/demo.html" target="_blank" rel="noopener">任务六：通过HTML及CSS模拟报纸排版</a><br><a href="https://littleheng.github.io/ife_baidu_2017/xiaowei/task07/demo.html" target="_blank" rel="noopener">任务七：实现常见的技术产品官网的页面架构及样式布局</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;小薇学院&quot;&gt;&lt;a href=&quot;#小薇学院&quot; class=&quot;headerlink&quot; title=&quot;小薇学院&quot;&gt;&lt;/a&gt;小薇学院&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://littleheng.github.io/ife_baidu_2017/xiao
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>队列和堆栈</title>
    <link href="https://littleheng.gitee.io/2019/06/01/%E9%98%9F%E5%88%97%E5%92%8C%E5%A0%86%E6%A0%88/"/>
    <id>https://littleheng.gitee.io/2019/06/01/队列和堆栈/</id>
    <published>2019-06-01T09:45:56.000Z</published>
    <updated>2019-06-01T09:48:04.418Z</updated>
    
    <content type="html"><![CDATA[<h3 id="队列-queue-：先进先出数据结构-FIFO：first-in-first-out"><a href="#队列-queue-：先进先出数据结构-FIFO：first-in-first-out" class="headerlink" title="队列(queue)：先进先出数据结构(FIFO：first-in-first-out)"></a>队列(queue)：先进先出数据结构(FIFO：first-in-first-out)</h3><hr><h4 id="先进先出的数据结构"><a href="#先进先出的数据结构" class="headerlink" title="先进先出的数据结构"></a>先进先出的数据结构</h4><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/05/03/screen-shot-2018-05-03-at-151021.png" alt="&#39;&#39;"></p><p> 在FIFO数据结构中，添加到队列中的第一个元素将首先被处理。队列是典型的FIFO数据结构。insert操作也称为enqueue(入队)，新元素始终是被添加到队列的结尾。删除操作称为dequeue(出列)。你只被允许移除队列的第一个元素。</p><h4 id="队列-实现"><a href="#队列-实现" class="headerlink" title="队列-实现"></a>队列-实现</h4><blockquote><pre><code>package com.learn.dao;</code></pre></blockquote><pre><code>import java.util.ArrayList;import java.util.List;public class MyQueue {    private List&lt;Integer&gt; data;    private int p_start;    public MyQueue() {        data = new ArrayList&lt;Integer&gt;();        p_start = 0;    }    public boolean enqueue(int x) {        data.add(x);        return true;    }    public boolean dequeue() {        if (isEmpty()) {            return false;        }        p_start++;        return true;    }    public int front() {        return data.get(p_start);    }    public boolean isEmpty() {        return p_start &gt;= data.size();    }    public static void main(String[] args) {        MyQueue myQueue = new MyQueue();        myQueue.enqueue(3);        myQueue.enqueue(5);        if(!myQueue.isEmpty()) {            System.out.println(myQueue.front());        }        myQueue.dequeue();        if(!myQueue.isEmpty()) {            System.out.println(myQueue.front());        }        myQueue.dequeue();        if(!myQueue.isEmpty()) {            System.out.println(myQueue.front());        }    }}</code></pre><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a><em>缺点</em></h5><p>上面的实现很简单，但在某些情况下效率很低。随着起点指针的移动，会浪费越来越多的空间。如果我们空间有限时，这种实现是无法接受的。</p><h4 id="设计循环队列"><a href="#设计循环队列" class="headerlink" title="设计循环队列"></a>设计循环队列</h4><p>循环队列是线性数据结构，其中基于FIFO原理执行操作、，并且最后位置连接回第一位置以形成圆。它也被称为“环形缓冲区”。</p><p>循环队列的一个好处是我们可以利用队列前面的空格。在正常队列中，一旦队列变满，即使队列前面有空格，我们也无法插入下一个元素。但是使用循环队列，我们可以使用空下来的空间存储新值。</p><h5 id="我的实现"><a href="#我的实现" class="headerlink" title="我的实现"></a>我的实现</h5><blockquote><pre><code>package com.learn.dao;</code></pre></blockquote><pre><code>import java.util.ArrayList;import java.util.List;public class MyCircularQueue {    private List&lt;Integer&gt; data;    private int p_start;    private int p_end;    private int dataSize;    public MyCircularQueue(int k) {        data = new ArrayList&lt;Integer&gt;(k);        dataSize = k;        p_start = 0;        p_end = -1;    }    public boolean enqueue(int x) {        if(isFull()) {            return false;        }        if((p_end + 1) &gt;= dataSize) {            p_end = -1;        }        data.add(p_end + 1, x);        p_end++;        return true;    }    public boolean dequeue() {        if (isEmpty()) {            return false;        }        data.remove(p_start);        p_start++;        if(p_start &gt;= dataSize) {            p_start = 0;        }        return true;    }    public int front() {        if(isEmpty()) {            return -1;        }        return data.get(p_start);    }    public int rear() {        if(isEmpty()) {            return -1;        }        return data.get(p_end);        }    public boolean isEmpty() {        int size = data.size();        if(size &lt;= 0) {            return true;        }else{            return false;        }    }    public boolean isFull() {        int size = data.size();        if(size &gt;= dataSize) {            return true;        }else{            return false;        }    }    public static void main(String[] args) {        MyCircularQueue myQueue = new MyCircularQueue(3);        System.out.println(myQueue.enqueue(1));        System.out.println(myQueue.enqueue(2));        System.out.println(myQueue.enqueue(3));        System.out.println(myQueue.enqueue(4));        System.out.println(myQueue.rear());        System.out.println(myQueue.isFull());        System.out.println(myQueue.dequeue());        System.out.println(myQueue.enqueue(4));        System.out.println(myQueue.rear());    }}</code></pre><h5 id="其他实现"><a href="#其他实现" class="headerlink" title="其他实现"></a>其他实现</h5><blockquote><pre><code>class MyCircularQueue {</code></pre></blockquote><pre><code>    private int[] data;    private int head;    private int tail;    private int size;    /** Initialize your data structure here. Set the size of the queue to be k. */    public MyCircularQueue(int k) {        data = new int[k];        head = -1;        tail = -1;        size = k;    }    /** Insert an element into the circular queue. Return true if the operation is successful. */    public boolean enQueue(int value) {        if (isFull() == true) {            return false;        }        if (isEmpty() == true) {            head = 0;        }        tail = (tail + 1) % size;        data[tail] = value;        return true;    }    /** Delete an element from the circular queue. Return true if the operation is successful. */    public boolean deQueue() {        if (isEmpty() == true) {            return false;        }        if (head == tail) {            head = -1;            tail = -1;            return true;        }        head = (head + 1) % size;        return true;    }    /** Get the front item from the queue. */    public int Front() {        if (isEmpty() == true) {            return -1;        }        return data[head];    }    /** Get the last item from the queue. */    public int Rear() {        if (isEmpty() == true) {            return -1;        }        return data[tail];    }    /** Checks whether the circular queue is empty or not. */    public boolean isEmpty() {        return head == -1;    }    /** Checks whether the circular queue is full or not. */    public boolean isFull() {        return ((tail + 1) % size) == head;    }}</code></pre><h3 id="队列和BFS"><a href="#队列和BFS" class="headerlink" title="队列和BFS"></a>队列和BFS</h3><p>广度优先搜索算法(Breadth-first Search)的一个常见应用是找到从根节点到目标节点的最短路径。</p><h4 id="BFS-模板"><a href="#BFS-模板" class="headerlink" title="BFS-模板"></a>BFS-模板</h4><blockquote><pre><code>/** * Return the length of the shortest path between root and target node. */int BFS(Node root, Node target) {    Queue&lt;Node&gt; queue;  // store all nodes which are waiting to be processed    int step = 0;       // number of steps neeeded from root to current node    // initialize    add root to queue;    // BFS    while (queue is not empty) {        step = step + 1;        // iterate the nodes which are already in the queue        int size = queue.size();        for (int i = 0; i &lt; size; ++i) {            Node cur = the first node in queue;            return step if cur is target;            for (Node next : the neighbors of cur) {                add next to queue;            }            remove the first node from queue;        }    }    return -1;          // there is no path from root to target}</code></pre></blockquote><h4 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h4><p>给定’1’s(土地)和’0’s(水)的2d网格图，计算岛屿的数量。岛被水包围，通过水平或垂直连接相邻的土地而形成。你可以假设网格的所有四个边都被水包围。</p><h5 id="例1："><a href="#例1：" class="headerlink" title="例1："></a>例1：</h5><blockquote><p>  输入：<br>    11110<br>    11010<br>    11000<br>    00000</p></blockquote><pre><code>输出：1</code></pre><h5 id="例2："><a href="#例2：" class="headerlink" title="例2："></a>例2：</h5><blockquote><p>  输入：<br>    11000<br>    11000<br>    00100<br>    00011</p></blockquote><pre><code>输出：3</code></pre><h5 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h5><blockquote><pre><code>package com.learn.dao;</code></pre></blockquote><pre><code>public class NumIsland {    private char[][] gird;    private int rols;    private int cols;    private int count;    public NumIsland(char[][] tempGird) {        gird = tempGird;        count = 0;    }    public int calcIslandCount() {        rols = gird.length;        if(rols &lt;= 0){            return 0;        }        for(int i = 0; i &lt; rols; i++) {            cols = gird[i].length;            for(int j = 0; j &lt; cols; j++) {                if(gird[i][j] == &apos;1&apos;) {                    count++;                    doSearch(gird, i, j, rols, cols);                }            }        }        return count;    }    private void doSearch(char[][] tempGird, int i, int j, int rols, int cols) {        if(i &lt; 0 || j &lt; 0 || i &gt;= rols || j &gt;= cols) {            return;        }        if(gird[i][j] != &apos;1&apos;) {            return;        }        gird[i][j] = &apos;0&apos;;        doSearch(tempGird, i + 1, j, rols, cols);        doSearch(tempGird, i - 1, j, rols, cols);        doSearch(tempGird, i, j + 1, rols, cols);        doSearch(tempGird, i, j - 1, rols, cols);    }    public static void main(String[] args) {        char[][] grid = {{'1','1','1','1','0','0'},{'1','1','1','1','0','1'},{'1','1','1','1','0','0'},{'1','1','1','1','0','0'}};        NumIsland numIsland = new NumIsland(grid);        System.out.println(numIsland.calcIslandCount());    }}</code></pre><h4 id="Open-the-Lock-开锁"><a href="#Open-the-Lock-开锁" class="headerlink" title="Open the Lock 开锁"></a>Open the Lock 开锁</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;队列-queue-：先进先出数据结构-FIFO：first-in-first-out&quot;&gt;&lt;a href=&quot;#队列-queue-：先进先出数据结构-FIFO：first-in-first-out&quot; class=&quot;headerlink&quot; title=&quot;队列(queue
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Vue学习笔记（一）</title>
    <link href="https://littleheng.gitee.io/2017/08/02/%E5%88%9D%E8%AF%86Vue/"/>
    <id>https://littleheng.gitee.io/2017/08/02/初识Vue/</id>
    <published>2017-08-02T04:01:38.000Z</published>
    <updated>2019-07-08T07:23:14.958Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>&nbsp;&nbsp;vue是一个渐进式的MVVM框架，核心是支持数据声明式渲染。它是很灵活、高效的。<br>可以利用它的组件系统构建复杂的大型应用。而且它的库小，2.0引入的Virtual DOM<br>大大提升了性能，并且还做了其他的一些优化。他拥有各种的插件以应对实际应用中<br>的不同需求。vue-resource：可以与后台交互，vue-router：支持路由，vuex：<br>集中管理组件状态…<a href="https://cn.vuejs.org/v2/guide/" title="瞅一瞅" target="_blank" rel="noopener">官方教程在这里</a></p><p>先摆一个实例看看：</p><blockquote><pre><code>var vm = new Vue ({    //大括号表示vue实例需要接收的构造参数    el: &quot;#app&quot;,    //实例、模型需要监听的实例、模型范围、对象    data: {        //模型      title: &quot;Hello Vue&quot;    },    filters: {          //局部过滤器    },    mounted: function () {        //属于生命周期的一部分：实例创建完成，代码都已编译完成，      this.cartView();          然后需要初始化的操作（相当于jquery的ready）(1.0: ready; 2.0: mounted;)    },    methods: {    //页面所有的事件的绑定都在这里定义      cartView: function () {        this.title = &quot;Vue Hello&quot;;      }    }     }); Vue.filter();    //全局过滤器：通过Vue实例的filter方法定义</code></pre></blockquote><h3 id="基础指令"><a href="#基础指令" class="headerlink" title="基础指令"></a>基础指令</h3><blockquote><p>v-on：事件的绑定<br>  v-if：DOM显示隐藏(DOM显示时有，不显示时无)<br>  v-for：循环：主要用于表格等数组的循环<br>  v-model：表单里面使用(双向)<br>  v-text：渲染<br>  v-show：DOM显示隐藏(display:block/display:none：DOM一直存在)<br>  v-bind：绑定属性：给DOM添加属性<br>  v-html：更新元素的innerHTML</p></blockquote><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><p>&nbsp;&nbsp;把一个网页拆成多个组件，拼成一个网页，独立的组件可能在其他的页面有复用，<br>比如头尾的复用。</p><h3 id="全局组件"><a href="#全局组件" class="headerlink" title="全局组件"></a>全局组件</h3><p>注册一个全局组件</p><blockquote><pre><code>Vue.component(&apos;my-component&apos;, {    template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;  })</code></pre></blockquote><p>注册之后，就可以在父实例的模块中以自定义元素的形式使用。</p><blockquote><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;my-component&gt;&lt;/my-component&gt;&lt;/div&gt;</code></pre></blockquote><h3 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件</h3><p>通过使用组件实例选项注册，可以使组件只在另一个实例/组件的作用域中可用：</p><blockquote><pre><code>var Child = {      template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos;      }</code></pre></blockquote><blockquote><pre><code>new Vue({      // ...    components: {        // &lt;my-component&gt; 将只在父模板可用        &apos;my-component&apos;: Child      }  })</code></pre></blockquote><h3 id="data-必须是函数"><a href="#data-必须是函数" class="headerlink" title="data 必须是函数"></a>data 必须是函数</h3><p> 通过Vue构造器传入的各种选项大多数都可以在组件中使用，data 是一个例外，它必须是函数。</p><blockquote><pre><code>Vue.component(&apos;simple-counter&apos;, {       template: &apos;&lt;div&gt;&lt;/div&gt;&apos;,       data: function () {         return {           counter: 0         }       }  })</code></pre></blockquote><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>主要是对接口返回的字段进行业务的转换。</p><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><ul><li>下载js库到本地</li><li>引用CDN文件路径（官网示例）</li><li>通过npm安装</li></ul><hr><p>记录一下npm安装过程：  </p><p>一、创建package.json(配置)</p><ol><li>npm init：初始化文件夹</li><li>初始化配置<blockquote><p>name：名称<br> verison：版本<br> description：描述<br> entry point：入口文件<br> test command：测试<br> git repository：git仓库<br> keywords：关键词<br> author：作者<br> license：协议（MIT：完全开源）</p></blockquote></li></ol><p>二、安装Vue</p><blockquote><pre><code>cnpm install vue --save：配置到package.json文件默认的依赖库dependencies中</code></pre><p>注：cnpm install vue –save-dev：配置到package.json的开发模式的依赖库中（devDependencies）</p></blockquote><p>三、安装vue-resource</p><blockquote><pre><code>cnpm install vue-resource --save</code></pre></blockquote><!-- 最后附上一张Vue生命周期的图：![](https://littleheng.github.io/images/lifecycle.png) -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;vue是一个渐进式的MVVM框架，核心是支持数据声明式渲染。它是很灵活、高效的。&lt;br&gt;可以利用它的
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>hello markdown!</title>
    <link href="https://littleheng.gitee.io/2017/07/21/Hello-Hexo/"/>
    <id>https://littleheng.gitee.io/2017/07/21/Hello-Hexo/</id>
    <published>2017-07-21T06:18:59.000Z</published>
    <updated>2019-07-08T06:34:45.208Z</updated>
    
    <content type="html"><![CDATA[<h6 id="这是H6"><a href="#这是H6" class="headerlink" title="这是H6"></a>这是H6</h6><h2 id="这是H2"><a href="#这是H2" class="headerlink" title="这是H2"></a>这是H2</h2><h1 id="这是H1"><a href="#这是H1" class="headerlink" title="这是H1"></a>这是H1</h1><!-- # 这是H1 --><blockquote><p>Markdown标记区块引用是使用类似email中用&gt;的引用方式。如果你还熟悉在email信件中的引言部分，你就知道怎么在Markdown文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上&gt;；&gt;</p></blockquote><blockquote><p>Markdown也允许你偷懒只在整个段落的第一行最前面加上；</p></blockquote><blockquote><blockquote><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的&gt;；</p></blockquote><p>Back to the first level.</p></blockquote><blockquote><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol></blockquote><blockquote><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><ul><li>Markdown支持有序列表和无序列表</li></ul><ul><li>无序列表使用星号、加号或是减号作为列表标记；</li></ul><ol><li>有序列表则使用数字接着一个英文句点；</li></ol><ul><li>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好。列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</li></ul><ol><li>列表项目可以包含多个段落，每个项目下的段落都必须缩进4个空格或是1个制表符。</li></ol><ul><li>如果要在列表项目内放进引用，那&gt;就需要缩进。</li></ul><ul><li>如果要放代码块的话，该区块就需要缩进两次，也就是8个空格或是2个制表符。</li></ul><pre><code>要在Markdown中建立代码区块很简单，只要简单地缩进4个空格或是1个制表符就可以</code></pre><hr><hr><hr><ul><li>分隔线</li></ul><blockquote><p>Markdown支持两种形式的链接语法：行内式和参考式两种形式。不管是哪一种，链接文字都是用[方括号]来标记。</p></blockquote><p>This is <a href="http://example.com/" title="Title" target="_blank" rel="noopener">an example</a> inline link.</p><p><a href="http://example.net/" target="_blank" rel="noopener">This link</a> has no title attribute.</p><blockquote><p>如果你要链接到同样主机的资源，你可以使用相对路径。</p></blockquote><p>See my <a href="/about/">About</a> page for details.</p><blockquote><p>参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记。</p></blockquote><p>This is <a href="http://example.com/" title="Optional Title Here" target="_blank" rel="noopener">an example</a> reference-style link.</p><blockquote><p>你也可以选择性地在两个方括号中间加上一个空格。</p></blockquote><p>This is <a href="http://example.com/" title="Optional Title Here" target="_blank" rel="noopener">an example</a> reference-style link.</p><blockquote><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来。</p></blockquote><p>链接内容定义的形式为：</p><ul><li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li><li>接着一个冒号</li><li>接着一个以上的空格或制表符</li><li>接着链接的地址</li><li>选择性的接着title内容，可以用单引号、双引号或是括弧包着</li></ul><blockquote><p>下面这三种链接的定义都是相同：<br><a href="http://example.com/" title="Optional Title Here" target="_blank" rel="noopener">foo</a>: <a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a>  “Optional Title Here”</p></blockquote><blockquote><p>请注意：有一个已知的问题是Markdown.pl 1.0.1会忽略单引号包起来的链接title。</p></blockquote><blockquote><p>链接网址也可以用方括号包起来：<br><a href="http://example.com/" title="Optional Title Here" target="_blank" rel="noopener">id</a>: “Optional Title Here”</p></blockquote><blockquote><p>你也可以把title属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p></blockquote><blockquote><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。<br>链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面这两个链接是一样的：</p></blockquote><p>[link text][a]<br>[link text][A]</p><blockquote><p>隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果要让Google链接到google.com，你可以简化成：</p></blockquote><p><a href="http://google.com/" target="_blank" rel="noopener">Google</a></p><blockquote><p>然后定义链接内容：</p></blockquote><blockquote><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p></blockquote><p>Visit <a href="http://daringfireball.net/" target="_blank" rel="noopener">Daring Fireball</a> for more information.</p><blockquote><p>然后接着定义链接</p></blockquote><blockquote><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现的段落的后面，你也可以把它放在文件的最后面，就好像注解一样。</p></blockquote><blockquote><p>下面是一个参考式链接的范例：</p></blockquote><p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><blockquote><p>如果改成用链接名称的方式写：</p></blockquote><p>I get 10 times more traffic from <a href="http://google.com/" target="_blank" rel="noopener">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or <a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a>.</p><blockquote><p>下面是用行内式写的同样一段内容的Markdown文件，提供作为比较之用：</p></blockquote><p>I get 10 times more traffic from <a href="http://google.com/" title="Google" target="_blank" rel="noopener">Google</a> than from <a href="http://search.yahoo.com/" title="Yahoo Search" target="_blank" rel="noopener">Yahoo</a> or<br><a href="http://search.msn.com/" title="MSN Search" target="_blank" rel="noopener">MSN</a></p><blockquote><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有81个字符，但是用行内形式的却会增加到176个字元，如果使用纯HTML格式来写，会有234个字元，在HTML格式中，标签比文本还要多。</p></blockquote><blockquote><p>使用Markdown的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p></blockquote><p><strong>强调</strong></p><blockquote><p>Markdown使用星号(<em>)和底线(_)作为标记强调字词的符号，被</em>或<em>包围的字词会被转成<em>标签包围，用两个*或</em>包起来的话，则会被转成<strong>，例如：</strong></em></p></blockquote><p><em>single asterisks</em><br><em>single underscores</em><br><strong>double asterisks</strong><br><strong>double underscores</strong></p><blockquote><p>你可以随便使用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p></blockquote><blockquote><p>强调也可以直接插在文字中间：</p></blockquote><p>un<em>friging</em>believable<br>un<strong>friging</strong>believable</p><blockquote><p>但是如果你的*和_两边都有空白的话，它们就只会被当成普通的符号。</p></blockquote><blockquote><p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线\：</p></blockquote><p>* this text is surrounded by literal asterisks*</p><p><strong>代码</strong></p><blockquote><p>如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如：</p></blockquote><p>Use the <code>printf()</code> function.</p><blockquote><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p></blockquote><p><code>There is a literal backtick (`) here.</code></p><blockquote><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p></blockquote><p>A single backtick in a code span: <code>`</code><br>A backtik-delimited string in a code span: <code>`foo`</code></p><blockquote><p>在代码区段内，&amp;和方括号都会被自动地转成HTML实体，这使得插入HTML原始码变得很容易。</p></blockquote><p><code>&amp;#8212;</code> is the decimal-encoded equivalent of <code>&amp;mdash;</code>.</p><p><strong>图片</strong></p><blockquote><p>很明显地，要在纯文字应用中设计一个[自然]的语法来插入图片是有一定难度的。</p></blockquote><blockquote><p>Markdown使用一种和链接很相似的语法来标记图片，同样也允许两种样式：行内式和参考式。</p></blockquote><blockquote><p>行内式的图片语法看起来像是：</p></blockquote><p><img src="G:\我的图片\example.png" alt="image1"></p><p><img src="G:\我的图片\example.pngg" alt="image" title="Option title"></p><blockquote><p>详细叙述如下：</p><ul><li>一个惊叹号！</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的’title’文字。</li></ul></blockquote><p><img src="http://example.com/" alt="Alt text" title="Optional Title Here"></p><blockquote><p>id是图片参考的名称，图片参考的定义方式则和连结参考一样：</p></blockquote><blockquote><p>到目前为止，Markdown还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的<img>标签。</p></blockquote><p><strong>其它</strong></p><p><strong><strong>自动链接</strong></strong></p><p>Markdown支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来，Markdown就会自动把它转成链接，一般网址的链接文字就和链接地址一样，例如：</p><p><a href="http://example.com/" target="_blank" rel="noopener">http://example.com/</a></p><p>邮址的自动链接也很类似，只是Markdown会先做一个编码转换的过程，把文字字符转成16进位码的HTML实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p><p><a href="mailto:&#97;&#100;&#x64;&#114;&#101;&#x73;&#x73;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;" target="_blank" rel="noopener">&#97;&#100;&#x64;&#114;&#101;&#x73;&#x73;&#64;&#101;&#120;&#97;&#109;&#112;&#108;&#x65;&#46;&#99;&#111;&#109;</a></p><blockquote><p>在浏览器里面，这段字串会变成一个可以点击的链接。（这种做法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p></blockquote><p><strong>反斜杠</strong></p><p>Markdown可以利用反斜杠来插入一些在语法中有其他意义的符号，例如：如果你想要用星号*加在文字旁边的方式来做出强调效果（但不用<em>标签），你可以在星号的前面加上反斜杠：</em></p><p>*literal asterisks*</p><p>Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><p><img src="G:\我的图片\example.png" alt="image" title="I am an image"></p><h3 id="To-do-List"><a href="#To-do-List" class="headerlink" title="To-do List"></a>To-do List</h3><h3 id="待办和清单"><a href="#待办和清单" class="headerlink" title="待办和清单"></a>待办和清单</h3><ul><li style="list-style: none"><input type="checkbox" checked> 已完成项目1<ul><li style="list-style: none"><input type="checkbox" checked> 已完成事项1</li><li style="list-style: none"><input type="checkbox" checked> 已完成事项2</li></ul></li><li style="list-style: none"><input type="checkbox"> 待办事项1</li><li style="list-style: none"><input type="checkbox"> 待办事项2</li></ul><h3 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h3><h3 id="自上而下的顺序"><a href="#自上而下的顺序" class="headerlink" title="自上而下的顺序"></a>自上而下的顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">A--&gt;B</span><br></pre></td></tr></table></figure><h3 id="自下而上的顺序"><a href="#自下而上的顺序" class="headerlink" title="自下而上的顺序"></a>自下而上的顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">A--&gt;B</span><br></pre></td></tr></table></figure><h3 id="从左到右的顺序"><a href="#从左到右的顺序" class="headerlink" title="从左到右的顺序"></a>从左到右的顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt;B</span><br></pre></td></tr></table></figure><h3 id="从右到左的顺序"><a href="#从右到左的顺序" class="headerlink" title="从右到左的顺序"></a>从右到左的顺序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph RL</span><br><span class="line">A--&gt;B</span><br></pre></td></tr></table></figure><h3 id="流程图-1"><a href="#流程图-1" class="headerlink" title="流程图"></a>流程图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Chritmas] --&gt;B(Go Shopping)</span><br><span class="line">    B --&gt; C&#123;Let me think&#125;</span><br><span class="line">    C --&gt;|One| D[Laptop]</span><br><span class="line">    C --&gt;|Two| E[iPhone]</span><br><span class="line">    C --&gt;|There| F[Car]</span><br></pre></td></tr></table></figure><h3 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line">title 产品计划表</span><br><span class="line">section 初期阶段</span><br><span class="line">明确需求: 2016-03-01, 10d</span><br><span class="line">section 中期阶段</span><br><span class="line">跟进开发: 2016-03-11, 15d</span><br><span class="line">section 后期阶段</span><br><span class="line">走查测试: 2016-03-20, 9d</span><br></pre></td></tr></table></figure><table><thead><tr><th>header 1</th><th>header 2</th></tr></thead><tbody><tr><td>row 1 col 1</td><td>row 1 col 2</td></tr><tr><td>I</td><td>am</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h6 id=&quot;这是H6&quot;&gt;&lt;a href=&quot;#这是H6&quot; class=&quot;headerlink&quot; title=&quot;这是H6&quot;&gt;&lt;/a&gt;这是H6&lt;/h6&gt;&lt;h2 id=&quot;这是H2&quot;&gt;&lt;a href=&quot;#这是H2&quot; class=&quot;headerlink&quot; title=&quot;这是H2&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
</feed>
