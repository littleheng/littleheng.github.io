[{"title":"CSS随记","date":"2019-06-20T02:50:11.000Z","path":"2019/06/20/CSS随记/","text":"最近在公司做前端方面的工作，涉及到页面的编写。特此将刚刚知道的知识和碰过的坑整理一下，想到哪便写到哪。方便查阅。 写页面时注意兼容性，需要hack写法的就要多查阅不同浏览器版本的语法。也可以尝试新的技术。比如less、sass、stylus等。 开始 编写页面之前，记得初始化背景画布，因为浏览器先是加载DOM树，然后再将元素的默认属性画上去。有一些元素的默认属性会影响页面布局和定位。例如ul有默认的换行（外边距）和左内边距。 页面初始化需要的三种样式： 重置样式(reset)：html的许多标签是有默认样式的。需要将它们初始化。 公共样式(common)：公用的，可重复使用的样式。 独立样式：相对于某个页面单独使用的样式。 * { margin: 0; padding: 0px; &lt;!-- 值为1个时对应所有；值为2个时对应上下、左右；值为3个时对应上、左右、下；值为4个时分别对应上、右、下、左。 --&gt; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box; } body { background-color: #f8f8fd; font-size: 0.875rem; /* max-width: 10rem; */ } 可以设置默认的body背景色，元素之间切割有距离时露出背景色挺方便。 rem 使用rem做移动端网页，font-size应初始化在html根元素上，一般浏览器默认值为16px = 1rem。如果根元素为16px，那么每增加2px会增加0.125rem。每增加10px会增加0.625rem。(google浏览器默认中文最小字体为12px。&lt;12一律显示为12px大小。但允许设置为0。最小字体限制数可以在浏览器的设置中更改) max-width、min-width 使用max-width属性时，要小心，它可以让浏览器更好的处理小窗口的情况。这点在移动设备上尤为重要。我记得我使用了两次，第一次很成功，第二次页面就缩小了一半、、、暂时不知道为啥。使用min-width时，如果最小宽度大于可视宽度，会出现滚动条；当可视宽度变化为小于或等于最小宽度时，页面内容不会随宽度的缩小而缩小。可能部分内容需要移动滚动条才可查看。 margin 在我的印象中，一个简单的应用是块级元素（display: block）可以使用此属性轻松居中。简单又很酷。 div { display: block; margin: 0 auto; max-width: 600px; /* 当div的宽度大于可视区的宽度时，浏览器会显示一个水平滚动条来容纳页面。用这个属性可以避免这种情况。更酷。 */ } box-sizingbox-sizing: border-box (内边距、边框宽度在设置的元素尺寸之内。盒子尺寸=设置的元素尺寸); box-sizing: content-box (内边距、边框宽度、外边距在设置的元素尺寸的外围。盒子实际尺寸&gt;=设置的元素尺寸); 注：为了向前兼容老版本的浏览器，某些属性会加前缀 -webkit-：google,safari私有属性; -moz-：firefox私有属性; -ms-：internet explorer私有属性; -o-：opera私有属性; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box; 布局 flex 弹性布局/伸缩盒子。设为flex布局后，子元素的float、clear、vertical-align属性将失效。 .flex { display: -webkit-flex; display: flex; } /* webkit内核的浏览器，必须加上-webkit-前缀 */ .div1 { -moz-box-flex: 1.0; -webkit-box-flex: 1.0; box-flex: 1.0; } .div2 { -moz-box-flex: 2.0; -webkit-box-flex: 2.0; box-flex: 2.0; } box box-flex主要让子容器针对父容器的宽度按一定规则进行划分 box属性box-orient | box-direction | box-align | box-pack | box-lines box-orient用来确定父容器里子容器的排列方式，是水平还是垂直。 horizontal | vertical | inline-axis | block-axis | inherit 给box设置horizontal或inline-axis属性其效果似乎表现一致，都可将子容器水平排列 如果父容器选择horizontal或inline-axis属性对子容器进行水平排列，其是对父容器的宽度进行分配划分。此时如果父容器定义了高度值，其子容器的高度值设置则无效状态，所有子容器的高度等于父容器的高度值；如果父容器不设置高度值，其子容器的高度值才有效并且取最大高度值的子容器的高度。 给box设置vertical或block-axis属性(此属性是默认值)其效果似乎表现一致，都可将子容器垂直排列 如果父容器选择vertical或block-axis属性对子容器进行垂直排列，其是对父容器的高度进行分配划分。此时如果父容器定义了宽度值，其子容器的宽度值设置则无效状态；如果父容器不设置宽度值，其子容器的宽度值才有效并且取最大宽度值的子容器的宽度。 inherit属性则是让子容器继承父容器的相关属性 box-direction用来确定父容器里的子容器排列顺序 normal | reverse | inherit &lt;!-- normal是默认值，按照HTML文档里结构的先后顺序依次展示 --&gt; &lt;!-- reverse表示反转 --&gt; box-align表示父容器里面子容器的垂直对齐方式 start | end | center | baseline | stretch &lt;!-- start：在box-align表示居顶对齐 --&gt; &lt;!-- end：在box-align表示居底对齐 --&gt; &lt;!-- center：在box-align表示居中对齐 --&gt; &lt;!-- stretch：在box-align表示拉伸，拉伸到与父容器等高 --&gt; box-pack表示父容器里面子容器的水平对齐方式 start | end | center | justify &lt;!-- start：在box-pack表示水平居左对齐 --&gt; &lt;!-- end：在box-pack表示水平居右对齐 --&gt; &lt;!-- center：在box-pack表示水平居中对齐 --&gt; &lt;!-- justify:在box-pack表示水平等分父容器宽度 --&gt; 移动web开发实践-css3（1）盒模型display:-webkit-box;的使用 position 定位和z-index配合使用时，可以将元素分为不同的层级。 常用的属性值 relative：相对定位 absolute：绝对定位 fixed：固定定位 relative 默认使用相对定位时，元素是相对于原有位置进行移动。移动完成后，它依然存在于原来的文档流中，所以在原有位置会有一段空白，如果不注意的话，就无法得到自己想要的效果。这时可以试试将元素的外边距设为负数看能不能达到相同的效果。 &lt;!-- 使用相对定位移动元素 --&gt; .cover { position: relative; top: -10px; &lt;!-- 会在原有位置留有空白 --&gt; } &lt;!-- 使用margin实现同样的效果 --&gt; .cover { margin-top: -10px; &lt;!-- 不会留有空白 --&gt; } absolute 使用绝对定位时，场景比较多的是先将父元素进行相对定位（relative），再将子元素设置为绝对定位（absolute），再根据实际情况上下左右调整距离。absolute定位的元素会脱离文档流，如果父元素里面没有其他在文档流中的元素时，父元素会塌陷。 .father { postion: relative } .son { postion: absolute; top: 0; bottom: 0; left: 0; right: 0; &lt;!-- son元素位置无变化，在父元素的左上角 --&gt; } fixed 固定定位可以将元素固定在某一个位置，不随滚动条的滚动而滚动，可以简单视为相对于可视区去定位。 &lt;!-- 实现移动端页面底部菜单浮动 --&gt; .footer-menu { width: 100%; position: fixed; bottom: 0; } 理解绝对定位 display 这是一个神奇的属性，有非常多的属性值。对布局很有用。不过我只掌握了常用的几种。（inline，inline-block，block） inline显示为内联元素，不可设置元素宽高、垂直居中，内边距只对左、右、下起作用，外边距只对左、右起作用。可设置文本对齐。不过使用绝对定位/浮动后，inline元素变为inline-block元素。以上的效果都有效。 inline-block这是我使用的比较多的一个值，也是我认为比较酷的一个选项。我经常使用它来将多个li元素排列为一行。它同时具备内联元素、块级元素的特点。（内联块状元素）它有如下特点：a. 和其他元素都在一行上b. 元素的宽、高、行高以及顶和底边距都可以设置c. vertical-align属性会影响到inline-block元素 ，你可能会把它的值设置为topd. 你需要设置每一列的宽度e. 如果HTML源代码中元素之间有空格，那么列与列 之间会产生空隙 block块级元素，可设置宽、高、内外边距、行高、、、独占一行。 百分比宽度 百分比是一种相对于包含块的计量单位。这个简直不要太爽。我经常利用它加inline-block实现li元素多行多列的布局。 父元素 div { width: 100%; background-color: #fff; } li { /* 宽度随需求而定，24%相当于一行显示4列 */ width: 24%; display: inline-block; /*这个是关键 */ text-align: center; /*可以让li内的元素居中 */ padding: 0.3125rem 03125rem; /*可以使布局更美观 */ position: relative; /*与子元素的绝对定位使用，你让它向东绝不会向西。 */ } 或者 li { width: 25%; float: left; } 清除浮动 经常出现一个情况，子元素全部浮动起来了，然后父元素没有被撑起来。曾经让我很抠脑壳。后来终于发现了两种方法解决这个顽疾。 在父元素中再添加一个子元素，设置子元素不透明度为0（opacity: 0）。然后子元素再clear: both。完美结局。 但是我更喜欢第二种，不用添加元素。使用伪类实现。 img(浮动的元素或父元素):after,img:before { content: &apos;&apos;, clear: both; } 经常使用的清除浮动的类： .clearfix:before,.clearfix:after { content: &apos;&apos;; display: table; } .clearfix:after { &lt;!-- 伪类与前面的冒号不能有空格，有空格会失效 --&gt; clear: both; } 这里有网页布局的许多知识。曾经帮助我实现css布局入门。 其他 一行文本省略overflow: hidden; text-overflow: ellipsis; // ... white-space: nowrap; 多行可以加上line-height和display配合使用。(貌似还有height) img和span行内对齐 只能说我太笨了，某天遇到这个坑时，纠结了半天，左调调右调调，就是对不齐，抠脑壳。最后发现是如此的简单。 img { width: 1.25rem; height: 1.25rem; vertical-align: middle; } span { display: inline-block; vertical-align: middle; } 注意：两个元素必须都是inline-block元素，并且img一定要设置宽、高。 @media(css3) 1、 语法 @media mediaType and|not|only (media feature) { /*CSS-Code;*/ } 媒体类型（mediaType ）：常用 all 用于所有设备 print 用于打印机和打印预览 screen 用于电脑屏幕，平板电脑，智能手机等。speech 应用于屏幕阅读器等发声设备 媒体功能（media feature）：常用 max-width 定义输出设备中的页面最大可见区域宽度 min-width 定义输出设备中的页面最小可见区域宽度 2、 准备工作 设置Meta标签 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt; width = device-width：宽度等于当前设备的宽度initial-scale：初始的缩放比例（默认设置为1.0，即代表不缩放）user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 加载兼容文件JS因为IE8既不支持HTML5也不支持CSS3 @media ，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果 设置IE渲染方式默认为最高(可选) &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt; 这段代码后面加了一个chrome=1，如果用户的电脑里安装了 chrome，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，如果没有安装，就显示IE最新的渲染模式。 实例 @media screen and (min-width:300px) and (max-width:500px) { /* CSS 代码 */ } min-width:300px 的作用是当文档宽度不小于 300px 的时候就应用 {} 里的CSS代码块，即大于等于 300pxmax-width:500px 的作用是当文档宽度不大于 500px 的时候就应用{} 里的CSS代码块，即小于等于 500px 原文链接 移动屏幕分辨率做移动端的页面，需要兼容各种型号，尺寸的设备。手机的话一般最小兼容到320*480，这是iphone4的屏幕分辨率。 阴影 box-shadow：边框阴影 box-shadow的常用属性值： h-shadow：必需。水平阴影的位置。允许负值 v-shadow：必需。垂直阴影的位置。允许负值 blur：可选。模糊距离 spread：可选。阴影的尺寸。 color：可选。阴影的颜色。请参阅 CSS 颜色值。 inset：可选。将外部阴影 (outset) 改为内部阴影 探索 CSS3 中的 box-shadow 属性 text-shadow：文本阴影 text-shadow的常用属性值： h-shadow：必需。水平阴影的位置。允许负值 v-shadow：必需。垂直阴影的位置。允许负值 blur：可选。模糊的距离 color：可选。阴影的颜色 border-collapseborder-collapse属性设置表格的边框是否被合并为一个单一的边框。 separate是默认值，边框会被分开，不会忽略border-spacing和empty-cells属性。 collapse如果可能，边框会合并为一个单一的边框，会忽略border-spacing和empty-cells属性。 table细边框table { border-collapse: collapse; border: none; width: 100%; &lt;!-- 可有可无，不影响效果，加上更美观 --&gt; } table td { border: solid #CBCBCB 1px; } li元素注意事项 设置：display: inline-block; 之后，由于li的默认display: list-item(有小黑点); 所以相当于你改变了它的本质属性，小黑点会消失。 设置：float: left; 元素会从左至右排列；float: right; 元素会从右至左排列。 list-style-position: inside;li元素的小黑点的显示位置是由list-style-position属性决定的，默认效果是outside，在li的外面，它不占用li的宽度；还可以设置成inside，在li的里面，会占用li的宽度。 去a下划线a { text-decoration: none; } button按钮常用样式 去掉按钮默认灰色边框 button { border: none; } 按钮边角圆角度 button { border-radius: 10px; } 按钮点击时去掉蓝色边框 button { outline: none; } 画倒三角&lt;div class=&quot;bg-black&quot;&gt; &lt;span class=&quot;triangle-down&quot;&gt; &lt;/span&gt; &lt;/div&gt; * { margin: 0; padding: 0; box-sizing: border-box; } .bg-black { width: 100%; height: 50px; text-align: center; } .triangle-down { width: 0; height: 0; line-height: 45px; border-color: transparent transparent rgba(37,74,108,1.00); border-width: 0px 5px 8px 5px; border-style: solid; } opacity opacity：不透明度，取值从0-1，越大越不透明，越小越透明。 当向父元素的背景添加opacity属性，所有它的子元素也变为透明，若子元素为文本则不容易看清楚，如果不想使子元素透明，使用RGBA颜色值 font-variantfont-variant:small-caps; &lt;!-- 浏览器会显示小型大写字母的字体 --&gt; text-transformnone &lt;!-- 默认。定义带有小写字母和大写字母的标准的文本 --&gt; capitalize &lt;!-- 文本中的每个单词以大写字母开头 --&gt; uppercase &lt;!-- 定义仅有大写字母 --&gt; lowercase &lt;!-- 定义无大写字母，仅有小写字母 --&gt; overflow-wrap 用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行(word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”) normal &lt;!-- 表示在正常的单词结束处换行 --&gt; break-word &lt;!-- 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行 --&gt; text-alignleft：向左对齐 right：向右对齐 center：居中对齐 justify：两端对齐 预知后事如何，请看下回分解…","tags":[]},{"title":"动效设计","date":"2019-06-19T09:39:54.000Z","path":"2019/06/19/动效设计/","text":"概念运用动态的图片传递信息和表达氛围 作用 流畅过渡 高效反馈 增强操纵 帮助引导 升华体验 注意 简洁适度，避免复杂繁琐 平衡开发成本 平衡性能和响应度，避免动效卡慢","tags":[]},{"title":"百度前端学院-2017","date":"2019-06-04T03:03:09.000Z","path":"2019/06/04/百度前端学院-2017/","text":"小薇学院 任务一：零基础HTML编码任务二：零基础HTML及CSS编码（一）任务三：三栏式布局任务四：定位和居中问题任务五：零基础HTML及CSS编码（二）任务六：通过HTML及CSS模拟报纸排版任务七：实现常见的技术产品官网的页面架构及样式布局","tags":[]},{"title":"队列和堆栈","date":"2019-06-01T09:45:56.000Z","path":"2019/06/01/队列和堆栈/","text":"队列(queue)：先进先出数据结构(FIFO：first-in-first-out) 先进先出的数据结构 在FIFO数据结构中，添加到队列中的第一个元素将首先被处理。队列是典型的FIFO数据结构。insert操作也称为enqueue(入队)，新元素始终是被添加到队列的结尾。删除操作称为dequeue(出列)。你只被允许移除队列的第一个元素。 队列-实现 package com.learn.dao; import java.util.ArrayList; import java.util.List; public class MyQueue { private List&lt;Integer&gt; data; private int p_start; public MyQueue() { data = new ArrayList&lt;Integer&gt;(); p_start = 0; } public boolean enqueue(int x) { data.add(x); return true; } public boolean dequeue() { if (isEmpty()) { return false; } p_start++; return true; } public int front() { return data.get(p_start); } public boolean isEmpty() { return p_start &gt;= data.size(); } public static void main(String[] args) { MyQueue myQueue = new MyQueue(); myQueue.enqueue(3); myQueue.enqueue(5); if(!myQueue.isEmpty()) { System.out.println(myQueue.front()); } myQueue.dequeue(); if(!myQueue.isEmpty()) { System.out.println(myQueue.front()); } myQueue.dequeue(); if(!myQueue.isEmpty()) { System.out.println(myQueue.front()); } } } 缺点上面的实现很简单，但在某些情况下效率很低。随着起点指针的移动，会浪费越来越多的空间。如果我们空间有限时，这种实现是无法接受的。 设计循环队列循环队列是线性数据结构，其中基于FIFO原理执行操作、，并且最后位置连接回第一位置以形成圆。它也被称为“环形缓冲区”。 循环队列的一个好处是我们可以利用队列前面的空格。在正常队列中，一旦队列变满，即使队列前面有空格，我们也无法插入下一个元素。但是使用循环队列，我们可以使用空下来的空间存储新值。 我的实现 package com.learn.dao; import java.util.ArrayList; import java.util.List; public class MyCircularQueue { private List&lt;Integer&gt; data; private int p_start; private int p_end; private int dataSize; public MyCircularQueue(int k) { data = new ArrayList&lt;Integer&gt;(k); dataSize = k; p_start = 0; p_end = -1; } public boolean enqueue(int x) { if(isFull()) { return false; } if((p_end + 1) &gt;= dataSize) { p_end = -1; } data.add(p_end + 1, x); p_end++; return true; } public boolean dequeue() { if (isEmpty()) { return false; } data.remove(p_start); p_start++; if(p_start &gt;= dataSize) { p_start = 0; } return true; } public int front() { if(isEmpty()) { return -1; } return data.get(p_start); } public int rear() { if(isEmpty()) { return -1; } return data.get(p_end); } public boolean isEmpty() { int size = data.size(); if(size &lt;= 0) { return true; }else{ return false; } } public boolean isFull() { int size = data.size(); if(size &gt;= dataSize) { return true; }else{ return false; } } public static void main(String[] args) { MyCircularQueue myQueue = new MyCircularQueue(3); System.out.println(myQueue.enqueue(1)); System.out.println(myQueue.enqueue(2)); System.out.println(myQueue.enqueue(3)); System.out.println(myQueue.enqueue(4)); System.out.println(myQueue.rear()); System.out.println(myQueue.isFull()); System.out.println(myQueue.dequeue()); System.out.println(myQueue.enqueue(4)); System.out.println(myQueue.rear()); } } 其他实现 class MyCircularQueue { private int[] data; private int head; private int tail; private int size; /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) { data = new int[k]; head = -1; tail = -1; size = k; } /** Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) { if (isFull() == true) { return false; } if (isEmpty() == true) { head = 0; } tail = (tail + 1) % size; data[tail] = value; return true; } /** Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() { if (isEmpty() == true) { return false; } if (head == tail) { head = -1; tail = -1; return true; } head = (head + 1) % size; return true; } /** Get the front item from the queue. */ public int Front() { if (isEmpty() == true) { return -1; } return data[head]; } /** Get the last item from the queue. */ public int Rear() { if (isEmpty() == true) { return -1; } return data[tail]; } /** Checks whether the circular queue is empty or not. */ public boolean isEmpty() { return head == -1; } /** Checks whether the circular queue is full or not. */ public boolean isFull() { return ((tail + 1) % size) == head; } } 队列和BFS广度优先搜索算法(Breadth-first Search)的一个常见应用是找到从根节点到目标节点的最短路径。 BFS-模板 /** * Return the length of the shortest path between root and target node. */ int BFS(Node root, Node target) { Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed int step = 0; // number of steps neeeded from root to current node // initialize add root to queue; // BFS while (queue is not empty) { step = step + 1; // iterate the nodes which are already in the queue int size = queue.size(); for (int i = 0; i &lt; size; ++i) { Node cur = the first node in queue; return step if cur is target; for (Node next : the neighbors of cur) { add next to queue; } remove the first node from queue; } } return -1; // there is no path from root to target } 岛屿数量给定’1’s(土地)和’0’s(水)的2d网格图，计算岛屿的数量。岛被水包围，通过水平或垂直连接相邻的土地而形成。你可以假设网格的所有四个边都被水包围。 例1： 输入： 11110 11010 11000 00000 输出：1 例2： 输入： 11000 11000 00100 00011 输出：3 实现代码 package com.learn.dao; public class NumIsland { private char[][] gird; private int rols; private int cols; private int count; public NumIsland(char[][] tempGird) { gird = tempGird; count = 0; } public int calcIslandCount() { rols = gird.length; if(rols &lt;= 0){ return 0; } for(int i = 0; i &lt; rols; i++) { cols = gird[i].length; for(int j = 0; j &lt; cols; j++) { if(gird[i][j] == &apos;1&apos;) { count++; doSearch(gird, i, j, rols, cols); } } } return count; } private void doSearch(char[][] tempGird, int i, int j, int rols, int cols) { if(i &lt; 0 || j &lt; 0 || i &gt;= rols || j &gt;= cols) { return; } if(gird[i][j] != &apos;1&apos;) { return; } gird[i][j] = &apos;0&apos;; doSearch(tempGird, i + 1, j, rols, cols); doSearch(tempGird, i - 1, j, rols, cols); doSearch(tempGird, i, j + 1, rols, cols); doSearch(tempGird, i, j - 1, rols, cols); } public static void main(String[] args) { char[][] grid = {{'1','1','1','1','0','0'},{'1','1','1','1','0','1'},{'1','1','1','1','0','0'},{'1','1','1','1','0','0'}}; NumIsland numIsland = new NumIsland(grid); System.out.println(numIsland.calcIslandCount()); } } Open the Lock 开锁","tags":[]}]