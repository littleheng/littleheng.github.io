[{"title":"毕向东Java基础部分笔记","date":"2019-10-31T03:19:43.000Z","path":"2019/10/31/毕向东Java基础部分笔记/","text":"进制特点 进制越大，表现形式越短。都是为了更方便的表示数据。 定义 字节：一个字节由8位二进制数组成，一个字节最大是255。 二进制：0-1，满2进1。 八进制：0-7，满8进1。用0开头表示，二进制的三位代表一位。 十进制：0-9，满10进1。 十六进制：0-9、A-F，满16进1。用0x开头表示，二进制的四位代表一位。 转换 * 十进制转二进制 原理：对十进制数进行除2运算，将每次运算的余数从右往左排列，直至除不尽为止。 例子：6 -&gt; 110 * 二进制转十进制 原理：二进制乘以2的运算 例子：110 &gt; 0\\*2（0）+ 1\\*2(1) + 1\\*2(2) = 0 + 2 + 4 = 6 或 (1*2+1)*2：从左往右第一个不为零的数是乘以2的因数，第二个是第一次相乘的余数，往后每有一位数就表示前面计算的结果要再乘以2还要加上本身所表示的余数，一直乘到最后一位。 * 十进制转十六进制 原理：先将十进制转为二进制，再将每四位二进制位转为一位十六进制位 例子：90 转为二进制：0101-1010 转为十进制：5-10 转为十六进制：0x5A * 十进制转八进制 原理：先将十进制转为二进制，再将每三位二进制位转为一位八进制位 例子：90 转为二进制：001-011-010 转为八进制：1-3-2 负数的二进制表现形式 例子：6 转为二进制：110 -6：其实就是6的二进制取反+1 取反：将二进制的1变成0，0变成1。 在内存中，一个数占四个字节，一个字节由八位二进制组成，因此6在内存中是这样的： &gt; 0000-0000 0000-0000 0000-0000 0000-0110 取反： &gt; 1111-1111 1111-1111 1111-1111 1111-1001 再加上1： &gt; 0000-0000 0000-0000 0000-0000 0000-0001 二进制加法：高位与高位相加，低位与低位相加，零个1为0，一个1为1， 两个1相加逢二进一。 因此结果为： &gt; 1111-1111 1111-1111 1111-1111 1111-1010 = -6 ps：负数的最高位都是1。 数据类型java语言是强类型语言，对于每一种数据都定义了明确的具体数据类型，在内存中分配了不同大小的内存空间。数据类型分为基本数据类型和引用数据类型 基本数据类型 byte(8位)、short(16)、int(32)、long()、float(单精度：32)、double(双精度：64)、char(16：0-6535)、boolean 引用数据类型 class(类)、interface(接口)、 数据类型的自动提升和强制转换 在不同类型数据进行运算时，数据类型占位数少的数据会自动提升到占位数大的数据类型再参与运算，其结果类型就是占位数大的数据类型。 如果想占位数大的数据和占位数小的数据运算时，其结果类型也为占位数小的数据类型，则可以使用强制类型转换。即在运算结果前使用占位数小的数据类型修饰，这样计算机在运算出最终结果时，则会去掉多余的位，只留下转换类型的位数。如果运算结果超出转换类型的范围，这样做可能会丢失精度。 ASCII码表 每一个字符在ASCII码表中都有对应的代码表示。a是97，A是65，0是48。所有计算机都支持ASCII码。 取模 取模即取余数，当左边数大于右边数时，结果是左边；当左边数等于右边数时，结果是0。当负数与正数取模时，数值正常取模，正负取决于左边被取模的数的正负。左边数是正数，其结果也是正数；反之亦然。 字符串连接符 字符串数据和任何数据使用+都是相连接，最终都会变成字符串。 位运算 按位与运算（&amp;）按位与运算是双目运算符，其功能是参与运算的两个数各对应的二进位相与。只有对应的两个二进位均为1时，结果位才为1，否则为0。参与运算的数以补码方式出现。 按位或运算（|）按位或运算也是双目运算符，其功能是参与运算的两个数各对应二进位相或。只要对应的两个二进位有一个为1时，结果位就为1。参与运算的两个数均以补码方式出现。 按位异或运算（^）按位异或运算符是双目运算符，其功能是参与运算的两个数各对应二进位相异或。只要对应的两个二进位相异时，结果位为1。参与运算的两个数均以补码的方式出现。 求反运算（~）求反运算符是单目运算符，具有右结合性。其功能是对参与运算的数的各二进位按位求反。 左移运算（&lt;&lt;）左移运算符是双目运算符。其功能是把“&lt;&lt;”左边的运算数的各二进制位全部左移若干位，由“&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。 右移运算（&gt;&gt;）右移运算符是双目运算符。其功能是把“&gt;&gt;”左边的运算数的各二进制位全部右移若干位，“&gt;&gt;”右边的 数指定移动的位数。 注意：对于有符号数，在右移时，符号位将随同移动。当为正数时，最高位补0，而为负数时，符号位为1，最高位是补0或是补1取决于编译系统的规定。Turbo C和很多系统规定为补1。 无符号右移（&gt;&gt;&gt;）无符号右移是双目运算符。无论最高位是0还是1，左边补齐0。（原码，反码，补码） 什么场景选择使用if，什么场景选择使用switch？ 如果判断的具体数值不多，而是符合byte short int char这四种类型，建议使用switch语句，因为效率稍高。其他情况，涉及对区间判断，以及对结果为boolean类型的判断，建议使用if。因为If的使用范围更广。 内存结构java程序在运行时，需要在内存中分配空间。为了提高运算效率，有对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。 栈内存 用于存储局部变量，当数据使用完，所占空间会自动释放。 堆内存 数组和对象，通过new建立的实例都存放在堆内存中。 每一个实体都有内存地址值。 实体中的变量都有默认初始化值。 实体不再被使用，会在不确定的时间内被垃圾回收器回收。 方法区 本地方法区 寄存器 垃圾回收机制 java语言本身是成长于c++，它优化了一些c++的特性而变得更简单、易学、易用。尤其是内存的优化要比c++做的好。 函数重载 在同一个类中，允许存在一个以上的同名函数，只要它们的参数个数或者参数类型不同即可。与返回值类型无关，只看参数列表。 什么时候使用重载？ 当定义的功能相同，但参与运算的未知内容不同。那么，这时就定义一个函数名称以表示此功能，方便阅读，而通过参数列表的不同来区分多个同名函数。 线程进程 进程是一个正在执行中的程序。每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制单元。 线程 线程就是进程中的一个独立的控制单元，线程控制着进程的执行。一个进程中至少有一个线程。 Java VM 启动的时候会有一个进程java.exe，该进程中至少一个线程负责java程序的执行。而且这个线程运行的代码存在于main方法中，该线程称之为主线程。 ps：jvm启动不止一个线程，还有负责垃圾回收机制的线程。 创建线程 创建线程的第一种方式：继承Thread类步骤： 定义类继承Thread 复写Thread类中的run方法。 目的：将自定义代码存储在run方法，让线程运行 调用线程的start方法。 该方法有两个作用：启动线程，调用run方法 ps：运行多线程程序后，发现运行结果每次都不一样。因为多个线程都获取cpu的执行权。cpu执行到谁，谁就运行。有一点是明确的，在某一时刻，只能有一个程序在运行。（多核除外）cpu在坐着快速的切换，以达到看上去是同时运行的效果。我们可以形象的把多线程的运行行为看成是多线程在互相抢夺cpu的执行权。 这就是多线程的一个特性：随机性。谁抢到谁执行，至于执行多长时间，cpu说了算。 为什么要覆盖run方法 Thread类用于描述线程。该类就定义了一个功能，用于存储线程要运行的代码，该存储功能就是run方法。也就是说Thread类中的run方法，用于存储线程要运行的代码。 start和run的区别 start是启动线程并执行线程的run方法。虚拟机会调用底层代码开启一个线程。当它执行时，多个线程会交替执行；run方法用于存储线程需要执行的代码。如果不执行start只执行run，相当于对象调用方法，其执行路径是单线程，执行结果是按照代码顺序输出，不会出现交替的结果。 线程的状态 ps：线程都有自己默认的名称：Thread-编号。该编号从0开始。此名称可以通过线程的构造函数自定义。 线程的一些方法 * static Thread currentThread()：获取当前线程对象 * getName()：获取线程名称 * setName()或构造函数：设置线程名称 创建线程的第二种方法：声明并实现Runnable接口步骤： 定义类实现Runnable接口 覆盖Runnable接口中的run方法 将线程要运行的代存放在run方法中 通过Thread类建立线程对象 将Runnable接口的子类对象作为实际参数传递给Thread类的构造函数 为什么要将Runnable接口的子类对象传递给Thread类的构造函数？因为自定义的run方法所属的对象是Runnable接口的子类对象。所以要让线程去指定对象的run方法，就必须明确该run方法所属的对象。 调用Thread类的start方法开启线程并调用Runnable接口子类的run方法 实现方式和继承方式有什么区别？ java只支持单继承。 实现方式避免了单继承的局限性。在定义线程时，建议使用实现方式。 继承方式其实也是实现了Runnable接口 区别继承Thread：线程代码存放在Thread子类的run方法中实现Runnable：线程代码存放在接口的子类的run方法中","tags":[]},{"title":"vue父子组件数据传递","date":"2019-09-21T02:50:43.000Z","path":"2019/09/21/vue父子组件数据传递/","text":"组件化父组件向子组件传递数据 首先定义子组件时在props对象中先把需要父组件传入的数据对象先定义好，当在父组件中使用这个子组件并传值时，子组件的props中的相应属性会接收到这个值，子组件就可以使用相应的props中的属性值。值得注意的是：props中的属性只允许在父组件中修改，不允许在子组件中修改，是为了避免数据发生混乱。不过可以通过watch监听到props中属性值的修改。 示例： 123456789101112131415161718// 子组件 props: &#123; visiable: &#123; type: Boolean, default: false &#125;, isMultiple: &#123; type: Boolean, default: false &#125;, title: &#123; type: String, default: &quot;客户列表&quot; &#125; &#125;// 父组件中引用子组件&lt;customer-list :visiable=&quot;customerListVisible&quot; :isMultiple=&quot;false&quot; :title=&quot;&apos;请选择受访客户&apos;&quot;&gt;&lt;/customer-list&gt; 子组件向父组件传递数据有时候当父组件需要获取到子组件的数据时，有两种方式可以实现。其中一种是通过ref实现；另一种是通过$emit实现。 使用ref时，只需要在引用子组件时用一个临时属性去对接子组件的ref标签，就可以在父组件中通过（this.$refs.临时属性.需要获取的属性名称）获取到子组件中data中的对应属性值。 实例： 12345678910111213141516171819// 子组件data() &#123; return &#123; multipleSelection: [] &#125;;&#125;,// 父组件中引用子组件&lt;customer-list ref=&quot;getSelectData&quot;&gt;&lt;/customer-list&gt;// 父组件中获取子组件data数据的vue代码data() &#123; return &#123; getSelectData: [] &#125;;&#125;,created() &#123; const customerList = this.$refs.getSelectData.multipleSelection;&#125;, 如果想使用$emit获取子组件的数据，则需要在定义子组件时在需要的时候触发$emit事件。$emit事件触发时可以指定在引用子组件时被触发的事件名称以及参数。然后在引用子组件时用一个自定义事件绑定被触发的事件，该自定义事件就能得到子组件传递的参数（可多个参数）。 实例： 123456789101112131415161718192021222324252627// 子组件&lt;template&gt; &lt;input type=&apos;file&apos; @change=&quot;changeUrl&quot; /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; changeUrl(e) &#123; this.$emit(&apos;changeUrl&apos;, e.currentTarget.files[0].path) &#125; &#125;&#125;// 父组件&lt;template&gt; &lt;uploadImg @changeUrl=&quot;getUrl&quot;&gt;&lt;/uploadImg&gt;&lt;/template&gt;&lt;script&gt;export default &#123; methods: &#123; getUrl(path) &#123; // 这个就是你要的path，并且会双向绑定 &#125; &#125;&#125;&lt;/script&gt; 补充 如果子组件的数据是个对象，当对象的某个属性值变化时，可以将此属性-值绑定为响应式数据，这样父组件中对应的对象也会变化，得到最新的值。 实例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 子组件&lt;template&gt; &lt;input :key=&quot;item.name&quot; v-for=&quot;item in dataItems&quot; :name=&quot;item.name&quot; :value=&quot;item.value&quot; type=&apos;text&apos; @change=&quot;changeValue(val, item)&quot; /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; dataItems: &#123; type: Array, defalt: [&#123; name: &apos;age&apos;, value: &apos;12&apos; &#125;, &#123; name: &apos;remark&apos;, value: &apos;测试&apos; &#125; &#125; &#125;, methods: &#123; changeValue(val, item) &#123; this.$set(this.dataItems, item.name, val); &#125; &#125;&#125;// 父组件&lt;template&gt; &lt;form-data :dataItems=&quot;dataItems&quot;&gt;&lt;/form-data&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data: &#123; return &#123; dataItems: [], &#125; &#125;, watch: &#123; dataItems: &#123; handler(newValue) &#123; console.log(newValue); &#125; &#125; &#125;&#125;&lt;/script&gt;","tags":[]},{"title":"CSS随记","date":"2019-06-20T02:50:11.000Z","path":"2019/06/20/CSS随记/","text":"最近在公司做前端方面的工作，涉及到页面的编写。特此将刚刚知道的知识和碰过的坑整理一下，想到哪便写到哪。方便查阅。 写页面时注意兼容性，需要hack写法的就要多查阅不同浏览器版本的语法。也可以尝试新的技术。比如less、sass、stylus等。 开始 编写页面之前，记得初始化背景画布，因为浏览器先是加载DOM树，然后再将元素的默认属性画上去。有一些元素的默认属性会影响页面布局和定位。例如ul有默认的换行（外边距）和左内边距。 页面初始化需要的三种样式： 重置样式(reset)：html的许多标签是有默认样式的。需要将它们初始化。 公共样式(common)：公用的，可重复使用的样式。 独立样式：相对于某个页面单独使用的样式。 * { margin: 0; padding: 0px; &lt;!-- 值为1个时对应所有；值为2个时对应上下、左右；值为3个时对应上、左右、下；值为4个时分别对应上、右、下、左。 --&gt; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box; } body { background-color: #f8f8fd; font-size: 0.875rem; /* max-width: 10rem; */ } 可以设置默认的body背景色，元素之间切割有距离时露出背景色挺方便。 rem 使用rem做移动端网页，font-size应初始化在html根元素上，一般浏览器默认值为16px = 1rem。如果根元素为16px，那么每增加2px会增加0.125rem。每增加10px会增加0.625rem。(google浏览器默认中文最小字体为12px。&lt;12一律显示为12px大小。但允许设置为0。最小字体限制数可以在浏览器的设置中更改) max-width、min-width 使用max-width属性时，要小心，它可以让浏览器更好的处理小窗口的情况。这点在移动设备上尤为重要。我记得我使用了两次，第一次很成功，第二次页面就缩小了一半、、、暂时不知道为啥。使用min-width时，如果最小宽度大于可视宽度，会出现滚动条；当可视宽度变化为小于或等于最小宽度时，页面内容不会随宽度的缩小而缩小。可能部分内容需要移动滚动条才可查看。 margin 在我的印象中，一个简单的应用是块级元素（display: block）可以使用此属性轻松居中。简单又很酷。 div { display: block; margin: 0 auto; max-width: 600px; /* 当div的宽度大于可视区的宽度时，浏览器会显示一个水平滚动条来容纳页面。用这个属性可以避免这种情况。更酷。 */ } box-sizingbox-sizing: border-box (内边距、边框宽度在设置的元素尺寸之内。盒子尺寸=设置的元素尺寸); box-sizing: content-box (内边距、边框宽度、外边距在设置的元素尺寸的外围。盒子实际尺寸&gt;=设置的元素尺寸); 注：为了向前兼容老版本的浏览器，某些属性会加前缀 -webkit-：google,safari私有属性; -moz-：firefox私有属性; -ms-：internet explorer私有属性; -o-：opera私有属性; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; -ms-box-sizing: border-box; -o-box-sizing: border-box; box-sizing: border-box; 布局 flex 弹性布局/伸缩盒子。设为flex布局后，子元素的float、clear、vertical-align属性将失效。 .flex { display: -webkit-flex; display: flex; } /* webkit内核的浏览器，必须加上-webkit-前缀 */ .div1 { -moz-box-flex: 1.0; -webkit-box-flex: 1.0; box-flex: 1.0; } .div2 { -moz-box-flex: 2.0; -webkit-box-flex: 2.0; box-flex: 2.0; } box box-flex主要让子容器针对父容器的宽度按一定规则进行划分 box属性box-orient | box-direction | box-align | box-pack | box-lines box-orient用来确定父容器里子容器的排列方式，是水平还是垂直。 horizontal | vertical | inline-axis | block-axis | inherit 给box设置horizontal或inline-axis属性其效果似乎表现一致，都可将子容器水平排列 如果父容器选择horizontal或inline-axis属性对子容器进行水平排列，其是对父容器的宽度进行分配划分。此时如果父容器定义了高度值，其子容器的高度值设置则无效状态，所有子容器的高度等于父容器的高度值；如果父容器不设置高度值，其子容器的高度值才有效并且取最大高度值的子容器的高度。 给box设置vertical或block-axis属性(此属性是默认值)其效果似乎表现一致，都可将子容器垂直排列 如果父容器选择vertical或block-axis属性对子容器进行垂直排列，其是对父容器的高度进行分配划分。此时如果父容器定义了宽度值，其子容器的宽度值设置则无效状态；如果父容器不设置宽度值，其子容器的宽度值才有效并且取最大宽度值的子容器的宽度。 inherit属性则是让子容器继承父容器的相关属性 box-direction用来确定父容器里的子容器排列顺序 normal | reverse | inherit &lt;!-- normal是默认值，按照HTML文档里结构的先后顺序依次展示 --&gt; &lt;!-- reverse表示反转 --&gt; box-align表示父容器里面子容器的垂直对齐方式 start | end | center | baseline | stretch &lt;!-- start：在box-align表示居顶对齐 --&gt; &lt;!-- end：在box-align表示居底对齐 --&gt; &lt;!-- center：在box-align表示居中对齐 --&gt; &lt;!-- stretch：在box-align表示拉伸，拉伸到与父容器等高 --&gt; box-pack表示父容器里面子容器的水平对齐方式 start | end | center | justify &lt;!-- start：在box-pack表示水平居左对齐 --&gt; &lt;!-- end：在box-pack表示水平居右对齐 --&gt; &lt;!-- center：在box-pack表示水平居中对齐 --&gt; &lt;!-- justify:在box-pack表示水平等分父容器宽度 --&gt; 移动web开发实践-css3（1）盒模型display:-webkit-box;的使用 position 定位和z-index配合使用时，可以将元素分为不同的层级。 常用的属性值 relative：相对定位 absolute：绝对定位 fixed：固定定位 relative 默认使用相对定位时，元素是相对于原有位置进行移动。移动完成后，它依然存在于原来的文档流中，所以在原有位置会有一段空白，如果不注意的话，就无法得到自己想要的效果。这时可以试试将元素的外边距设为负数看能不能达到相同的效果。 &lt;!-- 使用相对定位移动元素 --&gt; .cover { position: relative; top: -10px; &lt;!-- 会在原有位置留有空白 --&gt; } &lt;!-- 使用margin实现同样的效果 --&gt; .cover { margin-top: -10px; &lt;!-- 不会留有空白 --&gt; } absolute 使用绝对定位时，场景比较多的是先将父元素进行相对定位（relative），再将子元素设置为绝对定位（absolute），再根据实际情况上下左右调整距离。absolute定位的元素会脱离文档流，如果父元素里面没有其他在文档流中的元素时，父元素会塌陷。 .father { postion: relative } .son { postion: absolute; top: 0; bottom: 0; left: 0; right: 0; &lt;!-- son元素位置无变化，在父元素的左上角 --&gt; } fixed 固定定位可以将元素固定在某一个位置，不随滚动条的滚动而滚动，可以简单视为相对于可视区去定位。 &lt;!-- 实现移动端页面底部菜单浮动 --&gt; .footer-menu { width: 100%; position: fixed; bottom: 0; } 理解绝对定位 display 这是一个神奇的属性，有非常多的属性值。对布局很有用。不过我只掌握了常用的几种。（inline，inline-block，block） inline显示为内联元素，不可设置元素宽高、垂直居中，内边距只对左、右、下起作用，外边距只对左、右起作用。可设置文本对齐。不过使用绝对定位/浮动后，inline元素变为inline-block元素。以上的效果都有效。 inline-block这是我使用的比较多的一个值，也是我认为比较酷的一个选项。我经常使用它来将多个li元素排列为一行。它同时具备内联元素、块级元素的特点。（内联块状元素）它有如下特点：a. 和其他元素都在一行上b. 元素的宽、高、行高以及顶和底边距都可以设置c. vertical-align属性会影响到inline-block元素 ，你可能会把它的值设置为topd. 你需要设置每一列的宽度e. 如果HTML源代码中元素之间有空格，那么列与列 之间会产生空隙 block块级元素，可设置宽、高、内外边距、行高、、、独占一行。 百分比宽度 百分比是一种相对于包含块的计量单位。这个简直不要太爽。我经常利用它加inline-block实现li元素多行多列的布局。 父元素 div { width: 100%; background-color: #fff; } li { /* 宽度随需求而定，24%相当于一行显示4列 */ width: 24%; display: inline-block; /*这个是关键 */ text-align: center; /*可以让li内的元素居中 */ padding: 0.3125rem 03125rem; /*可以使布局更美观 */ position: relative; /*与子元素的绝对定位使用，你让它向东绝不会向西。 */ } 或者 li { width: 25%; float: left; } 清除浮动 经常出现一个情况，子元素全部浮动起来了，然后父元素没有被撑起来。曾经让我很抠脑壳。后来终于发现了两种方法解决这个顽疾。 在父元素中再添加一个子元素，设置子元素不透明度为0（opacity: 0）。然后子元素再clear: both。完美结局。 但是我更喜欢第二种，不用添加元素。使用伪类实现。 img(浮动的元素或父元素):after,img:before { content: &apos;&apos;, clear: both; } 经常使用的清除浮动的类： .clearfix:before,.clearfix:after { content: &apos;&apos;; display: table; } .clearfix:after { &lt;!-- 伪类与前面的冒号不能有空格，有空格会失效 --&gt; clear: both; } 这里有网页布局的许多知识。曾经帮助我实现css布局入门。 其他 一行文本省略overflow: hidden; text-overflow: ellipsis; // ... white-space: nowrap; 多行可以加上line-height和display配合使用。(貌似还有height) img和span行内对齐 只能说我太笨了，某天遇到这个坑时，纠结了半天，左调调右调调，就是对不齐，抠脑壳。最后发现是如此的简单。 img { width: 1.25rem; height: 1.25rem; vertical-align: middle; } span { display: inline-block; vertical-align: middle; } 注意：两个元素必须都是inline-block元素，并且img一定要设置宽、高。 @media(css3) 1、 语法 @media mediaType and|not|only (media feature) { /*CSS-Code;*/ } 媒体类型（mediaType ）：常用 all 用于所有设备 print 用于打印机和打印预览 screen 用于电脑屏幕，平板电脑，智能手机等。speech 应用于屏幕阅读器等发声设备 媒体功能（media feature）：常用 max-width 定义输出设备中的页面最大可见区域宽度 min-width 定义输出设备中的页面最小可见区域宽度 2、 准备工作 设置Meta标签 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt; width = device-width：宽度等于当前设备的宽度initial-scale：初始的缩放比例（默认设置为1.0，即代表不缩放）user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 加载兼容文件JS因为IE8既不支持HTML5也不支持CSS3 @media ，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果 设置IE渲染方式默认为最高(可选) &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge，chrome=1&quot;&gt; 这段代码后面加了一个chrome=1，如果用户的电脑里安装了 chrome，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，如果没有安装，就显示IE最新的渲染模式。 实例 @media screen and (min-width:300px) and (max-width:500px) { /* CSS 代码 */ } min-width:300px 的作用是当文档宽度不小于 300px 的时候就应用 {} 里的CSS代码块，即大于等于 300pxmax-width:500px 的作用是当文档宽度不大于 500px 的时候就应用{} 里的CSS代码块，即小于等于 500px 原文链接 移动屏幕分辨率做移动端的页面，需要兼容各种型号，尺寸的设备。手机的话一般最小兼容到320*480，这是iphone4的屏幕分辨率。 阴影 box-shadow：边框阴影 box-shadow的常用属性值： h-shadow：必需。水平阴影的位置。允许负值 v-shadow：必需。垂直阴影的位置。允许负值 blur：可选。模糊距离 spread：可选。阴影的尺寸。 color：可选。阴影的颜色。请参阅 CSS 颜色值。 inset：可选。将外部阴影 (outset) 改为内部阴影 探索 CSS3 中的 box-shadow 属性 text-shadow：文本阴影 text-shadow的常用属性值： h-shadow：必需。水平阴影的位置。允许负值 v-shadow：必需。垂直阴影的位置。允许负值 blur：可选。模糊的距离 color：可选。阴影的颜色 border-collapseborder-collapse属性设置表格的边框是否被合并为一个单一的边框。 separate是默认值，边框会被分开，不会忽略border-spacing和empty-cells属性。 collapse如果可能，边框会合并为一个单一的边框，会忽略border-spacing和empty-cells属性。 table细边框table { border-collapse: collapse; border: none; width: 100%; &lt;!-- 可有可无，不影响效果，加上更美观 --&gt; } table td { border: solid #CBCBCB 1px; } li元素注意事项 设置：display: inline-block; 之后，由于li的默认display: list-item(有小黑点); 所以相当于你改变了它的本质属性，小黑点会消失。 设置：float: left; 元素会从左至右排列；float: right; 元素会从右至左排列。 list-style-position: inside;li元素的小黑点的显示位置是由list-style-position属性决定的，默认效果是outside，在li的外面，它不占用li的宽度；还可以设置成inside，在li的里面，会占用li的宽度。 去a下划线a { text-decoration: none; } button按钮常用样式 去掉按钮默认灰色边框 button { border: none; } 按钮边角圆角度 button { border-radius: 10px; } 按钮点击时去掉蓝色边框 button { outline: none; } 画倒三角&lt;div class=&quot;bg-black&quot;&gt; &lt;span class=&quot;triangle-down&quot;&gt; &lt;/span&gt; &lt;/div&gt; * { margin: 0; padding: 0; box-sizing: border-box; } .bg-black { width: 100%; height: 50px; text-align: center; } .triangle-down { width: 0; height: 0; line-height: 45px; border-color: transparent transparent rgba(37,74,108,1.00); border-width: 0px 5px 8px 5px; border-style: solid; } opacity opacity：不透明度，取值从0-1，越大越不透明，越小越透明。 当向父元素的背景添加opacity属性，所有它的子元素也变为透明，若子元素为文本则不容易看清楚，如果不想使子元素透明，使用RGBA颜色值 font-variantfont-variant:small-caps; &lt;!-- 浏览器会显示小型大写字母的字体 --&gt; text-transformnone &lt;!-- 默认。定义带有小写字母和大写字母的标准的文本 --&gt; capitalize &lt;!-- 文本中的每个单词以大写字母开头 --&gt; uppercase &lt;!-- 定义仅有大写字母 --&gt; lowercase &lt;!-- 定义无大写字母，仅有小写字母 --&gt; overflow-wrap 用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行(word-wrap 属性原本属于微软的一个私有属性，在 CSS3 现在的文本规范草案中已经被重名为 overflow-wrap 。 word-wrap 现在被当作 overflow-wrap 的 “别名”) normal &lt;!-- 表示在正常的单词结束处换行 --&gt; break-word &lt;!-- 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被分割的单词会被强制分割换行 --&gt; text-alignleft：向左对齐 right：向右对齐 center：居中对齐 justify：两端对齐 预知后事如何，请看下回分解…","tags":[]},{"title":"百度前端学院-2017","date":"2019-06-04T03:03:09.000Z","path":"2019/06/04/百度前端学院-2017/","text":"小薇学院 任务一：零基础HTML编码任务二：零基础HTML及CSS编码（一）任务三：三栏式布局任务四：定位和居中问题任务五：零基础HTML及CSS编码（二）任务六：通过HTML及CSS模拟报纸排版任务七：实现常见的技术产品官网的页面架构及样式布局","tags":[]},{"title":"队列和堆栈","date":"2019-06-01T09:45:56.000Z","path":"2019/06/01/队列和堆栈/","text":"队列(queue)：先进先出数据结构(FIFO：first-in-first-out) 先进先出的数据结构 在FIFO数据结构中，添加到队列中的第一个元素将首先被处理。队列是典型的FIFO数据结构。insert操作也称为enqueue(入队)，新元素始终是被添加到队列的结尾。删除操作称为dequeue(出列)。你只被允许移除队列的第一个元素。 队列-实现 package com.learn.dao; import java.util.ArrayList; import java.util.List; public class MyQueue { private List&lt;Integer&gt; data; private int p_start; public MyQueue() { data = new ArrayList&lt;Integer&gt;(); p_start = 0; } public boolean enqueue(int x) { data.add(x); return true; } public boolean dequeue() { if (isEmpty()) { return false; } p_start++; return true; } public int front() { return data.get(p_start); } public boolean isEmpty() { return p_start &gt;= data.size(); } public static void main(String[] args) { MyQueue myQueue = new MyQueue(); myQueue.enqueue(3); myQueue.enqueue(5); if(!myQueue.isEmpty()) { System.out.println(myQueue.front()); } myQueue.dequeue(); if(!myQueue.isEmpty()) { System.out.println(myQueue.front()); } myQueue.dequeue(); if(!myQueue.isEmpty()) { System.out.println(myQueue.front()); } } } 缺点上面的实现很简单，但在某些情况下效率很低。随着起点指针的移动，会浪费越来越多的空间。如果我们空间有限时，这种实现是无法接受的。 设计循环队列循环队列是线性数据结构，其中基于FIFO原理执行操作、，并且最后位置连接回第一位置以形成圆。它也被称为“环形缓冲区”。 循环队列的一个好处是我们可以利用队列前面的空格。在正常队列中，一旦队列变满，即使队列前面有空格，我们也无法插入下一个元素。但是使用循环队列，我们可以使用空下来的空间存储新值。 我的实现 package com.learn.dao; import java.util.ArrayList; import java.util.List; public class MyCircularQueue { private List&lt;Integer&gt; data; private int p_start; private int p_end; private int dataSize; public MyCircularQueue(int k) { data = new ArrayList&lt;Integer&gt;(k); dataSize = k; p_start = 0; p_end = -1; } public boolean enqueue(int x) { if(isFull()) { return false; } if((p_end + 1) &gt;= dataSize) { p_end = -1; } data.add(p_end + 1, x); p_end++; return true; } public boolean dequeue() { if (isEmpty()) { return false; } data.remove(p_start); p_start++; if(p_start &gt;= dataSize) { p_start = 0; } return true; } public int front() { if(isEmpty()) { return -1; } return data.get(p_start); } public int rear() { if(isEmpty()) { return -1; } return data.get(p_end); } public boolean isEmpty() { int size = data.size(); if(size &lt;= 0) { return true; }else{ return false; } } public boolean isFull() { int size = data.size(); if(size &gt;= dataSize) { return true; }else{ return false; } } public static void main(String[] args) { MyCircularQueue myQueue = new MyCircularQueue(3); System.out.println(myQueue.enqueue(1)); System.out.println(myQueue.enqueue(2)); System.out.println(myQueue.enqueue(3)); System.out.println(myQueue.enqueue(4)); System.out.println(myQueue.rear()); System.out.println(myQueue.isFull()); System.out.println(myQueue.dequeue()); System.out.println(myQueue.enqueue(4)); System.out.println(myQueue.rear()); } } 其他实现 class MyCircularQueue { private int[] data; private int head; private int tail; private int size; /** Initialize your data structure here. Set the size of the queue to be k. */ public MyCircularQueue(int k) { data = new int[k]; head = -1; tail = -1; size = k; } /** Insert an element into the circular queue. Return true if the operation is successful. */ public boolean enQueue(int value) { if (isFull() == true) { return false; } if (isEmpty() == true) { head = 0; } tail = (tail + 1) % size; data[tail] = value; return true; } /** Delete an element from the circular queue. Return true if the operation is successful. */ public boolean deQueue() { if (isEmpty() == true) { return false; } if (head == tail) { head = -1; tail = -1; return true; } head = (head + 1) % size; return true; } /** Get the front item from the queue. */ public int Front() { if (isEmpty() == true) { return -1; } return data[head]; } /** Get the last item from the queue. */ public int Rear() { if (isEmpty() == true) { return -1; } return data[tail]; } /** Checks whether the circular queue is empty or not. */ public boolean isEmpty() { return head == -1; } /** Checks whether the circular queue is full or not. */ public boolean isFull() { return ((tail + 1) % size) == head; } } 队列和BFS广度优先搜索算法(Breadth-first Search)的一个常见应用是找到从根节点到目标节点的最短路径。 BFS-模板 /** * Return the length of the shortest path between root and target node. */ int BFS(Node root, Node target) { Queue&lt;Node&gt; queue; // store all nodes which are waiting to be processed int step = 0; // number of steps neeeded from root to current node // initialize add root to queue; // BFS while (queue is not empty) { step = step + 1; // iterate the nodes which are already in the queue int size = queue.size(); for (int i = 0; i &lt; size; ++i) { Node cur = the first node in queue; return step if cur is target; for (Node next : the neighbors of cur) { add next to queue; } remove the first node from queue; } } return -1; // there is no path from root to target } 岛屿数量给定’1’s(土地)和’0’s(水)的2d网格图，计算岛屿的数量。岛被水包围，通过水平或垂直连接相邻的土地而形成。你可以假设网格的所有四个边都被水包围。 例1： 输入： 11110 11010 11000 00000 输出：1 例2： 输入： 11000 11000 00100 00011 输出：3 实现代码 package com.learn.dao; public class NumIsland { private char[][] gird; private int rols; private int cols; private int count; public NumIsland(char[][] tempGird) { gird = tempGird; count = 0; } public int calcIslandCount() { rols = gird.length; if(rols &lt;= 0){ return 0; } for(int i = 0; i &lt; rols; i++) { cols = gird[i].length; for(int j = 0; j &lt; cols; j++) { if(gird[i][j] == &apos;1&apos;) { count++; doSearch(gird, i, j, rols, cols); } } } return count; } private void doSearch(char[][] tempGird, int i, int j, int rols, int cols) { if(i &lt; 0 || j &lt; 0 || i &gt;= rols || j &gt;= cols) { return; } if(gird[i][j] != &apos;1&apos;) { return; } gird[i][j] = &apos;0&apos;; doSearch(tempGird, i + 1, j, rols, cols); doSearch(tempGird, i - 1, j, rols, cols); doSearch(tempGird, i, j + 1, rols, cols); doSearch(tempGird, i, j - 1, rols, cols); } public static void main(String[] args) { char[][] grid = {{'1','1','1','1','0','0'},{'1','1','1','1','0','1'},{'1','1','1','1','0','0'},{'1','1','1','1','0','0'}}; NumIsland numIsland = new NumIsland(grid); System.out.println(numIsland.calcIslandCount()); } } Open the Lock 开锁","tags":[]},{"title":"Vue学习笔记（一）","date":"2017-08-02T04:01:38.000Z","path":"2017/08/02/初识Vue/","text":"基础知识&nbsp;&nbsp;vue是一个渐进式的MVVM框架，核心是支持数据声明式渲染。它是很灵活、高效的。可以利用它的组件系统构建复杂的大型应用。而且它的库小，2.0引入的Virtual DOM大大提升了性能，并且还做了其他的一些优化。他拥有各种的插件以应对实际应用中的不同需求。vue-resource：可以与后台交互，vue-router：支持路由，vuex：集中管理组件状态…官方教程在这里 先摆一个实例看看： var vm = new Vue ({ //大括号表示vue实例需要接收的构造参数 el: &quot;#app&quot;, //实例、模型需要监听的实例、模型范围、对象 data: { //模型 title: &quot;Hello Vue&quot; }, filters: { //局部过滤器 }, mounted: function () { //属于生命周期的一部分：实例创建完成，代码都已编译完成， this.cartView(); 然后需要初始化的操作（相当于jquery的ready）(1.0: ready; 2.0: mounted;) }, methods: { //页面所有的事件的绑定都在这里定义 cartView: function () { this.title = &quot;Vue Hello&quot;; } } }); Vue.filter(); //全局过滤器：通过Vue实例的filter方法定义 基础指令 v-on：事件的绑定 v-if：DOM显示隐藏(DOM显示时有，不显示时无) v-for：循环：主要用于表格等数组的循环 v-model：表单里面使用(双向) v-text：渲染 v-show：DOM显示隐藏(display:block/display:none：DOM一直存在) v-bind：绑定属性：给DOM添加属性 v-html：更新元素的innerHTML 组件&nbsp;&nbsp;把一个网页拆成多个组件，拼成一个网页，独立的组件可能在其他的页面有复用，比如头尾的复用。 全局组件注册一个全局组件 Vue.component(&apos;my-component&apos;, { template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos; }) 注册之后，就可以在父实例的模块中以自定义元素的形式使用。 &lt;div id=&quot;app&quot;&gt; &lt;my-component&gt;&lt;/my-component&gt; &lt;/div&gt; 局部组件通过使用组件实例选项注册，可以使组件只在另一个实例/组件的作用域中可用： var Child = { template: &apos;&lt;div&gt;A custom component!&lt;/div&gt;&apos; } new Vue({ // ... components: { // &lt;my-component&gt; 将只在父模板可用 &apos;my-component&apos;: Child } }) data 必须是函数 通过Vue构造器传入的各种选项大多数都可以在组件中使用，data 是一个例外，它必须是函数。 Vue.component(&apos;simple-counter&apos;, { template: &apos;&lt;div&gt;&lt;/div&gt;&apos;, data: function () { return { counter: 0 } } }) 过滤器主要是对接口返回的字段进行业务的转换。 安装环境 下载js库到本地 引用CDN文件路径（官网示例） 通过npm安装 记录一下npm安装过程： 一、创建package.json(配置) npm init：初始化文件夹 初始化配置 name：名称 verison：版本 description：描述 entry point：入口文件 test command：测试 git repository：git仓库 keywords：关键词 author：作者 license：协议（MIT：完全开源） 二、安装Vue cnpm install vue --save：配置到package.json文件默认的依赖库dependencies中 注：cnpm install vue –save-dev：配置到package.json的开发模式的依赖库中（devDependencies） 三、安装vue-resource cnpm install vue-resource --save","tags":[]},{"title":"hello markdown!","date":"2017-07-21T06:18:59.000Z","path":"2017/07/21/Hello-Hexo/","text":"这是H6这是H2这是H1 Markdown标记区块引用是使用类似email中用&gt;的引用方式。如果你还熟悉在email信件中的引言部分，你就知道怎么在Markdown文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上&gt;；&gt; Markdown也允许你偷懒只在整个段落的第一行最前面加上； 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的&gt;； Back to the first level. 这是第一行列表项。 这是第二行列表项。 return shell_exec(&quot;echo $input | $markdown_script&quot;); Markdown支持有序列表和无序列表 无序列表使用星号、加号或是减号作为列表标记； 有序列表则使用数字接着一个英文句点； 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好。列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 列表项目可以包含多个段落，每个项目下的段落都必须缩进4个空格或是1个制表符。 如果要在列表项目内放进引用，那&gt;就需要缩进。 如果要放代码块的话，该区块就需要缩进两次，也就是8个空格或是2个制表符。 要在Markdown中建立代码区块很简单，只要简单地缩进4个空格或是1个制表符就可以 分隔线 Markdown支持两种形式的链接语法：行内式和参考式两种形式。不管是哪一种，链接文字都是用[方括号]来标记。 This is an example inline link. This link has no title attribute. 如果你要链接到同样主机的资源，你可以使用相对路径。 See my About page for details. 参考式的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记。 This is an example reference-style link. 你也可以选择性地在两个方括号中间加上一个空格。 This is an example reference-style link. 接着，在文件的任意处，你可以把这个标记的链接内容定义出来。 链接内容定义的形式为： 方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字 接着一个冒号 接着一个以上的空格或制表符 接着链接的地址 选择性的接着title内容，可以用单引号、双引号或是括弧包着 下面这三种链接的定义都是相同：foo: http://example.com/ “Optional Title Here” 请注意：有一个已知的问题是Markdown.pl 1.0.1会忽略单引号包起来的链接title。 链接网址也可以用方括号包起来：id: “Optional Title Here” 你也可以把title属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看： 网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。链接辨别标签可以有字母、数字、空白和标点符号，但是并不区分大小写，因此下面这两个链接是一样的： [link text][a][link text][A] 隐式链接标记功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果要让Google链接到google.com，你可以简化成： Google 然后定义链接内容： 由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词： Visit Daring Fireball for more information. 然后接着定义链接 链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现的段落的后面，你也可以把它放在文件的最后面，就好像注解一样。 下面是一个参考式链接的范例： I get 10 times more traffic from Google than from Yahoo or MSN. 如果改成用链接名称的方式写： I get 10 times more traffic from Google than from Yahoo or MSN. 下面是用行内式写的同样一段内容的Markdown文件，提供作为比较之用： I get 10 times more traffic from Google than from Yahoo orMSN 参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有81个字符，但是用行内形式的却会增加到176个字元，如果使用纯HTML格式来写，会有234个字元，在HTML格式中，标签比文本还要多。 使用Markdown的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。 强调 Markdown使用星号()和底线(_)作为标记强调字词的符号，被或包围的字词会被转成标签包围，用两个*或包起来的话，则会被转成，例如： single asteriskssingle underscoresdouble asterisksdouble underscores 你可以随便使用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。 强调也可以直接插在文字中间： unfrigingbelievableunfrigingbelievable 但是如果你的*和_两边都有空白的话，它们就只会被当成普通的符号。 如果要在文字前后直接插入普通的星号或底线，你可以用反斜线\\： * this text is surrounded by literal asterisks* 代码 如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the printf() function. 如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： There is a literal backtick (`) here. 代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号： A single backtick in a code span: `A backtik-delimited string in a code span: `foo` 在代码区段内，&amp;和方括号都会被自动地转成HTML实体，这使得插入HTML原始码变得很容易。 &amp;#8212; is the decimal-encoded equivalent of &amp;mdash;. 图片 很明显地，要在纯文字应用中设计一个[自然]的语法来插入图片是有一定难度的。 Markdown使用一种和链接很相似的语法来标记图片，同样也允许两种样式：行内式和参考式。 行内式的图片语法看起来像是： 详细叙述如下： 一个惊叹号！ 接着一个方括号，里面放上图片的替代文字 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的’title’文字。 id是图片参考的名称，图片参考的定义方式则和连结参考一样： 到目前为止，Markdown还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的标签。 其它 自动链接 Markdown支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来，Markdown就会自动把它转成链接，一般网址的链接文字就和链接地址一样，例如： http://example.com/ 邮址的自动链接也很类似，只是Markdown会先做一个编码转换的过程，把文字字符转成16进位码的HTML实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： &#x61;&#100;&#x64;&#114;&#x65;&#115;&#x73;&#64;&#101;&#120;&#97;&#x6d;&#x70;&#108;&#101;&#x2e;&#x63;&#x6f;&#109; 在浏览器里面，这段字串会变成一个可以点击的链接。（这种做法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。） 反斜杠 Markdown可以利用反斜杠来插入一些在语法中有其他意义的符号，例如：如果你想要用星号*加在文字旁边的方式来做出强调效果（但不用标签），你可以在星号的前面加上反斜杠： *literal asterisks* Markdown支持以下这些符号前面加上反斜杠来帮助插入普通的符号： To-do List待办和清单 已完成项目1 已完成事项1 已完成事项2 待办事项1 待办事项2 流程图自上而下的顺序12graph TBA--&gt;B 自下而上的顺序12graph BTA--&gt;B 从左到右的顺序12graph LRA--&gt;B 从右到左的顺序12graph RLA--&gt;B 流程图123456graph TD A[Chritmas] --&gt;B(Go Shopping) B --&gt; C&#123;Let me think&#125; C --&gt;|One| D[Laptop] C --&gt;|Two| E[iPhone] C --&gt;|There| F[Car] 甘特图123456789ganttdateFormat YYYY-MM-DDtitle 产品计划表section 初期阶段明确需求: 2016-03-01, 10dsection 中期阶段跟进开发: 2016-03-11, 15dsection 后期阶段走查测试: 2016-03-20, 9d header 1 header 2 row 1 col 1 row 1 col 2 I am","tags":[]}]